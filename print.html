<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Linux Desktop Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/last-changed.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "frappe";
        </script>

        <!-- Custom JS scripts for mdbook-pdf PDF generation -->
        <script type='text/javascript'>
            let markAllContentHasLoadedForPrinting = () =>
                window.setTimeout(
                    () => {
                        let p = document.createElement('div');
                        p.setAttribute('id', 'content-has-all-loaded-for-mdbook-pdf-generation');
                        document.body.appendChild(p);
                    }, 100
                );

            window.addEventListener('load', () => {
                // Expand all the <details> elements for printing.
                r = document.getElementsByTagName('details');
                for (let i of r)
                    i.open = true;

                try {
                    MathJax.Hub.Register.StartupHook('End', markAllContentHasLoadedForPrinting);
                } catch (e) {
                    markAllContentHasLoadedForPrinting();
                }
            });
        </script>
    <div style="display: none"><a href="#foreward">foreward</a><a href="#chapter1-whylinux">chapter1-whylinux</a><a href="#chapter2-linuxmadeof">chapter2-linuxmadeof</a><a href="#chapter3-bootloaders">chapter3-bootloaders</a><a href="#chapter4-servercli">chapter4-servercli</a><a href="#chapter5-drives">chapter5-drives</a><a href="#chapter6-hardware">chapter6-hardware</a></div>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Linux Desktop Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreward"><a class="header" href="#foreward">Foreward</a></h1>
<p>This book was created to enable anyone to install and use Linux effectively. Its creation was made possible thanks to the help and support of the Chris Titus Tech community. The information contained in this book is drawn from thousands of comments, research, and real-world experiences from users who utilize Linux as their daily driver.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://christitus.com">Official Website</a></li>
<li><a href="https://github.com/ChrisTitusTech">GitHub Projects</a></li>
<li><a href="https://www.youtube.com/c/ChrisTitusTech">YouTube Tutorials</a></li>
<li><a href="https://cttstore.com">Digital Downloads</a></li>
</ul>
<h2 id="special-features-of-this-book"><a class="header" href="#special-features-of-this-book">Special Features of This Book</a></h2>
<p>Throughout this book, you will find links to videos designed to enhance the learning experience. Some concepts are better demonstrated visually than explained in text, and these resources will help you better understand the topics discussed. This book serves as a guide to accelerate your learning, allowing you to absorb knowledge efficiently without needing to watch hundreds of hours of videos.</p>
<h2 id="before-you-begin"><a class="header" href="#before-you-begin">Before you Begin</a></h2>
<p>Before diving into the content, understand that Linux works very differently from Windows or macOS. It is not just a different operating system; it is a different way of thinking about how computers work. This book will help you transition to this new mindset, but it will take time to adjust. Be patient with yourself and embrace the learning process.</p>
<p>Also, when referring to ANY resources the date of the resource is important. This book is designed to be a living document, meaning it will be updated with new information and resources as they become available. Always check the date of the resources you are using to ensure they are still relevant and accurate. Linux moves quickly, and what was true yesterday may not be true today. This book will help you stay up-to-date with the latest information and resources available, but check the last updated date on the resources you are using to ensure they are still relevant and accurate. Each chapter will have a last updated date at the end of the chapter, and you can find the latest version of this book at <a href="https://thelinuxbook.com">https://thelinuxbook.com</a>.</p>
<footer id="last-change">Last change: 2025-06-15</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1---starting-linux"><a class="header" href="#chapter-1---starting-linux">Chapter 1 - Starting Linux</a></h1>
<p>Linux is a powerful and versatile operating system that gives you complete control over your computer. Whether you're looking for stability, security, or customization, Linux has something to offer for everyone. In this chapter, we'll explore the basics of Linux, including its distributions, release types, and modularity.</p>
<p>Why Choose Linux over Windows or MacOS?: <a href="https://youtu.be/DNg2M88_Hl0">https://youtu.be/DNg2M88_Hl0</a></p>
<h2 id="distributions"><a class="header" href="#distributions">Distributions</a></h2>
<p>Linux by itself doesn't include programs and things to make a fully function computer. So we have Linux distributions. There are many Distributions, in fact, hundreds of them that can be rather confusing. However there are three main branches that comprise the most amount of users and will be the focus of this book.</p>
<p>Overview of All Distributions on Linux: <a href="https://youtu.be/DKFnqAtEOvc">https://youtu.be/DKFnqAtEOvc</a></p>
<h3 id="debian-based-distributions"><a class="header" href="#debian-based-distributions">Debian-Based Distributions</a></h3>
<p>These are the majority of Linux users and most online guides are written with them in mind. They typically are very stable and long term support. When you hear Ubuntu, Linux Mint, Pop OS, Elementary OS, KDE Neon, Peppermint, and much more... they are all based around Debian. This means how you install programs and the package manger is all the same. This is typically where most users start from. Anytime you see the command <em>apt install</em> or <em>.deb</em> package the installation instructions are geared for a this distribution branch.</p>
<h3 id="rhel-based-distributions"><a class="header" href="#rhel-based-distributions">RHEL-Based Distributions</a></h3>
<p>RedHat Enterprise Linux is what RHEL stands for. This is the backbone of many Linux servers as any RHEL based distribution is built with security and stability in mind. There are 3 distributions that most think of when it comes to the RHEL category. RedHat Enterprise Linux (Subscription-Based), CentOS (RHEL clone but no subscription), and Fedora. The package manager for these distributions is <em>dnf install</em> or <em>yum install</em> and utilizing the <em>.rpm</em> packages you download from sites.</p>
<h3 id="arch-based-distributions"><a class="header" href="#arch-based-distributions">Arch-Based Distributions</a></h3>
<p>Arch Linux is a user created distribution that isn't backed by any company and has some unique features as a result. The main distributions you hear about in this category are Arch Linux and Manjaro. It's package manager syntax looks like <em>pacman -S packagename</em> and doesn't have downloadable packages like Debian or RHEL distros. It does however have a unique feature called the AUR (Arch User Repository) and is able to build programs on the fly. While this is incredibly powerful, it can also be dangerous as these aren't vetted and sometimes have old packages that are out of date. So if using the AUR always check the site to make sure it is up to date and is a legitimate source.</p>
<div class="table-wrapper"><table><thead><tr><th>Distribution Type</th><th>Examples</th><th>Package Manager Syntax</th><th>Key Features</th></tr></thead><tbody>
<tr><td>Debian-Based</td><td>Ubuntu, Linux Mint, Pop OS</td><td><code>apt install</code></td><td>Stable, beginner-friendly</td></tr>
<tr><td>RHEL-Based</td><td>CentOS, Fedora</td><td><code>dnf install</code> / <code>yum install</code></td><td>Secure, server-focused</td></tr>
<tr><td>Arch-Based</td><td>Arch Linux, Manjaro</td><td><code>pacman -S</code></td><td>Rolling release, highly customizable</td></tr>
</tbody></table>
</div>
<h2 id="release-types"><a class="header" href="#release-types">Release Types</a></h2>
<p>Lets go over the two types of distribution releases you will encounter Rolling and Stable. Both have their pros and cons, but depending on how you use your PC one might better than the other for you.</p>
<p>LTS vs Rolling Release: <a href="https://youtu.be/B-NG5gW5QnM">https://youtu.be/B-NG5gW5QnM</a></p>
<h3 id="rolling-release"><a class="header" href="#rolling-release">Rolling Release</a></h3>
<p>Arch Linux is what is called a rolling release, which is a version of Linux that isn't tied to a single version of the Linux kernel. By comparison, Ubuntu does 6 month releases where it will not update major system components. Arch can update the Linux kernel and other core system components every week or everyday in some instances. This is a double edged sword, as you get the latest and greatest features, but you are also prone to more bugs.</p>
<h3 id="stable-lts-release"><a class="header" href="#stable-lts-release">Stable LTS Release</a></h3>
<p>Debian and RHEL based distributions are typically using a proven release cycle. Each distribution can have different release schedules and vary from a couple months to several years. The distributions that are specifically called LTS (Long Term Support) are made with longevity in mind. The support structure can range from 5 years (Ubuntu LTS) to 10 Years (CentOS Versions). The downside to using stable releases is the packages are sometimes considered old and are not as up to date. However, these versions will run for years and are extremely stable.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>The power of Linux is that no matter what distribution you choose, it is modular. You can modify and make massive changes to drastically change the user experience. This gives you the power to make Linux operate how ever you see fit and you are the only thing holding it back.</p>
<p>Linux's modularity allows you to tailor your system to your needs. Whether you're building a lightweight system for an old laptop or a high-performance gaming rig, Linux gives you the tools to make it happen. Here are some examples:</p>
<ul>
<li><strong>Server Setup:</strong> Install only essential server packages and skip the desktop environment.</li>
<li><strong>Lightweight Desktop:</strong> Use LXDE or XFCE for older hardware.</li>
<li><strong>Gaming System:</strong> Install Steam, Proton, and GPU drivers for a complete gaming experience.</li>
</ul>
<h2 id="what-distribution-should-you-use"><a class="header" href="#what-distribution-should-you-use">What Distribution Should You Use</a></h2>
<p>I don't consider Linux complex, but more of a rabbit hole of infinite possibilities. This is very overwhelming for a new user and often misunderstood. That is why I always recommend popular distributions with widespread support and resembling the operating system they are coming from. For Windows Users, I recommend starting with Linux Mint and for MacOS users I recommend Pop OS! as it has more Mac feel out of the box.</p>
<h3 id="tips-for-choosing-a-distribution"><a class="header" href="#tips-for-choosing-a-distribution">Tips for Choosing a Distribution</a></h3>
<ul>
<li><strong>Windows Users:</strong> Start with Linux Mint for a familiar experience.</li>
<li><strong>MacOS Users:</strong> Try Pop OS for a sleek and modern interface.</li>
<li><strong>New Gaming Users:</strong> Bazzite gives an controlled environment with lots of gaming support by default. System shouldn't be</li>
<li><strong>Advanced Gaming Users:</strong> Nobara is made by Glorius Eggroll and is a gaming focused distribution with many tweaks and optimizations for gaming out of the box. It also allows for lots of system customization.</li>
<li><strong>Advanced Users:</strong> Explore Arch Linux or Fedora for more control and cutting-edge features.</li>
</ul>
<h3 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h3>
<ul>
<li>Linux Mint Official Site - <a href="https://linuxmint.com">https://linuxmint.com</a></li>
<li>Pop OS Official Site - <a href="https://pop.system76.com">https://pop.system76.com</a></li>
<li>Bazzite Official Site - <a href="https://bazzite.gg">https://bazzite.gg</a></li>
<li>Nobara Official Site - <a href="https://nobaraproject.org">https://nobaraproject.org</a></li>
<li>Arch Linux Wiki - <a href="https://wiki.archlinux.org">https://wiki.archlinux.org</a></li>
</ul>
<footer id="last-change">Last change: 2025-06-06</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2---what-is-a-linux-distribution-made-of"><a class="header" href="#chapter-2---what-is-a-linux-distribution-made-of">Chapter 2 - What is a Linux Distribution Made of?</a></h1>
<p>A Linux distribution comprises the same components that make up any operating system. Every Linux distribution has the following components, many of which can be customized to great effect. This is why there are so many options in Linux. With that in mind, here are the components of Linux:</p>
<h2 id="bootloader"><a class="header" href="#bootloader">Bootloader</a></h2>
<p>The bootloader is what boots the machine. There are two types of boot processes for any operating system: EFI and Legacy boot. Most Linux distributions use a package called <em>GRUB</em> to handle this process. However, some newer distributions have started using <em>systemd-boot</em> instead of GRUB.</p>
<h2 id="display-renderer"><a class="header" href="#display-renderer">Display Renderer</a></h2>
<p>For graphical elements to appear on the screen, either Xorg or Wayland is required to render the graphics. Both have their pros and cons. Xorg has been around since the beginning and is feature-rich, but its structure is messy. Wayland is newer and offers cleaner code. Personally, I use Xorg on most distributions because it does everything I need. However, most Linux distributions going forward will package Wayland by default and Xorg will eventually go away. Most servers don't need graphics and omit these packages altogether, relying only on a CLI (Command Line Interface).</p>
<p>Xorg vs Wayland: <a href="https://youtu.be/U_MBJcD3SFI">https://youtu.be/U_MBJcD3SFI</a></p>
<h2 id="display-manager"><a class="header" href="#display-manager">Display Manager</a></h2>
<p>The display manager is essentially the login manager that boots into your desktop environment or window manager.</p>
<h3 id="sddm"><a class="header" href="#sddm">SDDM</a></h3>
<p>This is the display manager for KDE. There are a lot of themes and support for both Wayland and Xorg.</p>
<h3 id="gdm"><a class="header" href="#gdm">GDM</a></h3>
<p>This is the display manager for GNOME. Much like SDDM, lots of themes and support for both Wayland and Xorg.</p>
<h3 id="lightdm"><a class="header" href="#lightdm">LightDM</a></h3>
<p>This is a more universal display manager that multiple desktop environments use because it is lightweight. Xorg Only, but is very lightweight and still widely used.</p>
<p>LightDM Customization: <a href="https://youtu.be/_dYqisDIcC0">https://youtu.be/_dYqisDIcC0</a></p>
<h3 id="none"><a class="header" href="#none">None</a></h3>
<p>You technically don't need a display manager, but this means you will boot into a CLI (Command Line Interface) prompt with no graphics. Alternatively, you could set a window manager or desktop environment to auto-launch without requiring a login.</p>
<h2 id="desktop-environments"><a class="header" href="#desktop-environments">Desktop Environments</a></h2>
<p>Desktop environments are the bread and butter of many distributions. These are typically an assortment of programs that dictate how programs are launched, displayed, and configured. Think of these as the look and feel of Linux.</p>
<p>Overview of Desktop Environments: <a href="https://youtu.be/mZa8AMWsYdQ">https://youtu.be/mZa8AMWsYdQ</a></p>
<h3 id="kde"><a class="header" href="#kde">KDE</a></h3>
<p>This is a Windows-style desktop environment with a start menu, taskbar, and basic floating window management. The workflow is very similar to Microsoft Windows. It has extensive theming capabilities, desktop widgets, and a vast array of built-in tools.</p>
<p>KDE Customization Video: <a href="https://youtu.be/nRtyFtpf5yU">https://youtu.be/nRtyFtpf5yU</a></p>
<h3 id="gnome"><a class="header" href="#gnome">GNOME</a></h3>
<p>GNOME has a unique workflow with window animations and extensions to expand its capabilities. It is unlike any other Desktop Environment out there but has great utility. Its strengths include robust system settings and support for scaling and tablet-style computers.</p>
<h3 id="cinnamon"><a class="header" href="#cinnamon">Cinnamon</a></h3>
<p>This is another Windows-style desktop environment, but it is more simplistic than KDE. The menus are more intuitive, and it has everything the user needs without bundling a ton of applications. This is my first recommendation for Windows users converting to Linux.</p>
<p>Cinnamon Customization Video: <a href="https://youtu.be/ZWA4F95A0Vc">https://youtu.be/ZWA4F95A0Vc</a> (Note: Cinnamon is made by the Linux Mint team.)</p>
<h3 id="mate"><a class="header" href="#mate">MATE</a></h3>
<p>MATE is based on GNOME 2 from the past. It looks a bit dated out of the box, but its minimal design makes it lightweight and functional. It has a traditional menu system, unlike the latest version of GNOME, and can be tweaked to the user's needs without using many resources.</p>
<h3 id="xfce"><a class="header" href="#xfce">XFCE</a></h3>
<p>Minimal, simplistic, and modular—that is XFCE's ethos, and it does a good job of it. It is one of my favorites, even though, like MATE, it is very ugly out of the box. After customization, it can look fantastic.</p>
<p>XFCE Customization Video: <a href="https://youtu.be/Y_x5svD2sZQ">https://youtu.be/Y_x5svD2sZQ</a></p>
<h3 id="lxqt--lxde"><a class="header" href="#lxqt--lxde">LXQt / LXDE</a></h3>
<p>LXQt is a very minimal desktop environment with a limited feature set. It is one of the lightest desktop environments on this list and is my recommendation for those using an old PC. Using nearly no resources, it simply gets the job done. LXDE is the older version before it morphed into LXQt.</p>
<h3 id="deepin"><a class="header" href="#deepin">Deepin</a></h3>
<p>This reminds me of macOS and is my recommendation for mac users coming to Linux who don't like GNOME. It is sleek and has a futuristic look out of the box.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>There are many other desktop environments that are less popular than the ones above, and I encourage you to explore them after familiarizing yourself with the ones listed.</p>
<h2 id="window-managers"><a class="header" href="#window-managers">Window Managers</a></h2>
<p>Window managers are often a point of confusion for new users, as people often mix them up with desktop environments. What is the difference? Desktop environments include a suite of tools and utilities, while window managers only manage windows.</p>
<p>I could write another book dedicated specifically to window managers, but I'd only recommend them for advanced users who are capable of making system modifications without the assistance of utilities. For example, adjusting your display settings.</p>
<p>Everything is set up by the user, from adjusting volume to launching programs. Depending on the window manager, you might need to edit text files to configure them or create shortcut keys for programs. Each one is unique and not for the faint of heart. In many of my videos, I use a modified version of DWM, which can be found on my GitHub: <a href="https://github.com/ChrisTitusTech/dwm-titus">https://github.com/ChrisTitusTech/dwm-titus</a></p>
<h2 id="package-manager"><a class="header" href="#package-manager">Package Manager</a></h2>
<p>This is probably the biggest factor that separates distributions and also makes many of them similar. There are a variety of package managers, but I will touch on the most popular ones that most distributions are based on.</p>
<h3 id="apt"><a class="header" href="#apt">APT</a></h3>
<p>Debian-based distributions (e.g., Ubuntu, Pop_OS!, Linux Mint, etc.) use APT, which is one of the oldest package managers on this list. It is also the most widely used. A good majority of Linux articles reference APT. The basic syntax is <code>apt install package</code>.</p>
<h3 id="dnf--yum"><a class="header" href="#dnf--yum">DNF / YUM</a></h3>
<p>RHEL-based distributions (e.g., Fedora, CentOS, Nobara, etc.) use these and dominate the business space. DNF is newer and has better dependency resolution, but you will still see YUM occasionally for legacy systems or older versions. Its basic syntax is <code>dnf install package</code>.</p>
<h3 id="pacman"><a class="header" href="#pacman">Pacman</a></h3>
<p>This is the oddball of the bunch, as it is used in Arch-based distributions (e.g., Manjaro, Garuda, EndeavourOS, etc.). It has non-standard syntax like <code>pacman -S package</code> to install a package.</p>
<h3 id="others-1"><a class="header" href="#others-1">Others</a></h3>
<p>There are many other package managers, but these encompass most of the popular Linux installations.</p>
<h3 id="flatpak--appimage--snapd"><a class="header" href="#flatpak--appimage--snapd">Flatpak / AppImage / SnapD</a></h3>
<p>These are agnostic of any distribution. This means the programs aren't install on the system-level but are self contained. Any dependencies are included with the package which makes them usable on anything Linux. Flatpak and snapd are easy to manage from the command line, but also have lots of files for each package. AppImage is contained within the singular <code>Package.AppImage</code> file. For managing AppImage files, I recommend using <code>gearlever</code> package. For managing permissions on flatpak files, I recommend the <code>flatseal</code> package. I do not recommend using SnapD at all as it is owned and poorly maintained by the company Canonical that distributes Ubuntu.</p>
<h3 id="misconceptions"><a class="header" href="#misconceptions">Misconceptions</a></h3>
<p>It should be noted that most programs can be compiled to work on pretty much any Linux distribution, and all the package manager does is make it easy for you to perform the installation. There are many other ways to install a program, such as building from source. However, most times this isn't needed, as even if a package is not available in your package manager, you can expand it by adding a repository to it, thus giving your package manager access to install even more programs on the fly. Even if this fails or a repository isn't available, you can utilize universal packages like Flatpak, Snap, or AppImage that can install on any system, no matter what package manager you are using.</p>
<h2 id="types-of-linux-installations"><a class="header" href="#types-of-linux-installations">Types of Linux Installations</a></h2>
<p>There are a variety of ways to install Linux, and I will go over them in depth. These methods are broken into three categories: Beginner, Intermediate, and Expert.</p>
<h3 id="beginner-installation"><a class="header" href="#beginner-installation">Beginner Installation</a></h3>
<p>This is extremely easy to do and is where a beginner should start. The downside to a beginner install is that it has less customizability, but it is an easier starting place for a novice user.</p>
<h3 id="intermediate-installation"><a class="header" href="#intermediate-installation">Intermediate Installation</a></h3>
<p>This method typically involves taking a base distribution from the server level and installing the needed packages as required. It yields a highly customized system with a minimal installation but requires the user to know which packages they want.</p>
<h3 id="expert-installation"><a class="header" href="#expert-installation">Expert Installation</a></h3>
<p>Much like intermediate installation, this method advances to not using desktop environments or bundles that install multiple packages. While this method can be tedious, it results in the most minimal installation, as it avoids installing unnecessary packages. However, it requires an extreme skill level to achieve. Often, the user is building packages or even compiling the base Linux kernel.</p>
<h2 id="progression"><a class="header" href="#progression">Progression</a></h2>
<p>The progression you will go through in Linux is much more than these types of installations, but I wanted to give you a path as you explore and move through these types of installations.</p>
<p>Build What You Want Video: <a href="https://youtu.be/fWHKAn5W2CA">https://youtu.be/fWHKAn5W2CA</a></p>
<footer id="last-change">Last change: 2025-06-06</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3---bootloaders-how-linux-is-loaded"><a class="header" href="#chapter-3---bootloaders-how-linux-is-loaded">Chapter 3 - Bootloaders: How Linux is Loaded</a></h1>
<p>There are many bootloaders available, but this chapter focuses on the two most widely used: GRUB 2 and systemd-boot.</p>
<h2 id="grub-2---the-most-widely-used"><a class="header" href="#grub-2---the-most-widely-used">GRUB 2 - The Most Widely Used</a></h2>
<p>GRUB 2 is the most popular bootloader for Linux, offering extensive functionality. It supports themes, multiboot setups, and various other features that make it highly versatile. For Windows/Linux multiboot systems, GRUB 2 is my recommended choice.</p>
<ul>
<li><strong>GRUB Manual Table of Contents:</strong> <a href="https://www.gnu.org/software/grub/manual/grub/html_node/index.html">https://www.gnu.org/software/grub/manual/grub/html_node/index.html</a></li>
</ul>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Before installing or updating GRUB, you need to create configuration files. One of the best resources for understanding GRUB is the <a href="https://wiki.gentoo.org/wiki/GRUB2">https://wiki.gentoo.org/wiki/GRUB2</a>.</p>
<h4 id="files-used-for-configuration"><a class="header" href="#files-used-for-configuration">Files Used for Configuration</a></h4>
<div class="table-wrapper"><table><thead><tr><th>File Location</th><th style="text-align: center">Editable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/boot/grub/grub.cfg</code></td><td style="text-align: center">No</td><td>Generated by <code>grub-mkconfig</code> and will be overwritten. Do not edit directly.</td></tr>
<tr><td><code>/etc/grub.d/*</code></td><td style="text-align: center">Yes</td><td>Contains scripts processed in numerical order (e.g., <code>10-boot</code>, <code>11-os</code>).</td></tr>
<tr><td><code>/etc/default/grub</code></td><td style="text-align: center">Yes</td><td>Primary configuration file for GRUB edits. Start here for modifications.</td></tr>
</tbody></table>
</div>
<h4 id="editing-grub-configuration-in-etcdefaultgrub"><a class="header" href="#editing-grub-configuration-in-etcdefaultgrub">Editing GRUB Configuration in <code>/etc/default/grub</code></a></h4>
<p>Below are common configuration entries in <code>/etc/default/grub</code>:</p>
<ul>
<li><strong><code>GRUB_DEFAULT</code></strong>: Specifies the default boot entry. Typically set to <code>0</code> for the first entry. Use <code>1</code> for the second entry, <code>2</code> for the third, and so on.</li>
<li><strong><code>GRUB_TIMEOUT_STYLE</code></strong>: Determines whether to display a menu (<code>MENU</code>) or hide it (<code>HIDDEN</code>). If hidden, the <code>GRUB_HIDDEN_TIMEOUT</code> variable controls the splash screen display.</li>
<li><strong><code>GRUB_TIMEOUT</code></strong>: Sets the menu display duration. If set to <code>-1</code>, the menu will never timeout and will wait for user input.</li>
<li><strong><code>GRUB_CMDLINE_LINUX_DEFAULT</code></strong>: Adds kernel options. Common examples:
<ul>
<li><code>quiet splash</code>: Hides verbose text output during boot.</li>
<li><code>nomodeset</code>: Bypasses modesetting, useful for booting NVIDIA systems to install drivers.</li>
<li><code>single</code>: Boots into single-user mode, useful for system modifications or resetting user passwords.</li>
<li>Variable declarations: Add system-specific variables, such as <code>keymap</code> or <code>vfio</code> for PCI passthrough.</li>
</ul>
</li>
<li><strong><code>GRUB_DISABLE_RECOVERY</code></strong>: Disables recovery entries. Setting this to <code>true</code> is recommended if recovery entries are rarely needed. You can edit GRUB directly during boot by pressing <code>e</code> when the menu appears.</li>
</ul>
<p>For a complete list of GRUB configuration variables, refer to the <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html">https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html</a>.</p>
<h4 id="sample-grub-configuration-etcdefaultgrub"><a class="header" href="#sample-grub-configuration-etcdefaultgrub">Sample GRUB Configuration (<code>/etc/default/grub</code>)</a></h4>
<p>Here’s an example configuration with no menu:</p>
<pre><code>GRUB_DEFAULT="0"
GRUB_TIMEOUT_STYLE="hidden"
GRUB_TIMEOUT="0"
GRUB_DISTRIBUTOR="`lsb_release -i -s 2&gt; /dev/null || echo Debian`"
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""
GRUB_DISABLE_RECOVERY="true"
GRUB_DISABLE_LINUX_RECOVERY="true"
</code></pre>
<h4 id="make-configuration-files"><a class="header" href="#make-configuration-files">Make Configuration files</a></h4>
<p>Make the configuration files with <code>grub-mkconfig</code> or <code>update-grub</code> on debian-based systems.</p>
<pre><code>grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>
<p>Manual page for grub-mkconfig: <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html#Simple-configuration">https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html#Simple-configuration</a></p>
<p>OR</p>
<pre><code>update-grub
</code></pre>
<p>Manual page for update-grub: <a href="https://manpages.debian.org/buster/grub-legacy/update-grub.8.en.html">https://manpages.debian.org/buster/grub-legacy/update-grub.8.en.html</a></p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>Once your configuration files are created, you can install GRUB onto your hard disk for booting. First, determine whether the installation is EFI or Legacy BIOS.</p>
<p>To check if you are using EFI:</p>
<pre><code>ls /sys/firmware/efi
</code></pre>
<p><em>If files are listed with the ls command you are on EFI</em></p>
<h4 id="efi-installation"><a class="header" href="#efi-installation">EFI Installation</a></h4>
<p>Efi installations consist of two partitions where Legacy BIOS can have one. This makes it unique, but can also cause a multiple problems when using manual partitioning. Prior to running these commands you need to make sure the partition is mounted!</p>
<p>Next, we need to install EFI to this partition with this command</p>
<pre><code>grub-install --efi-directory=/boot/efi
</code></pre>
<h4 id="bios-legacy-installation"><a class="header" href="#bios-legacy-installation">BIOS Legacy Installation</a></h4>
<p>Typically in a BIOS legacy setup you have one main partition mounted to / and you run the following command to install GRUB. <strong>Note: DO NOT USE Legacy where you can use EFI!</strong></p>
<pre><code>grub-install 
</code></pre>
<p>You can also do a variation of this if you have multiple drives or are dual booting. Find the drive you are installing it on using the command <code>lsblk</code> OR <code>blkid</code> as these give more information about your drive setup</p>
<p>Example usage when specifying a drive:</p>
<pre><code>grub-install /dev/sda
</code></pre>
<p>For the full usage of grub-install here is the manual page: <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html">https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html</a></p>
<h3 id="grub-videos"><a class="header" href="#grub-videos">GRUB Videos</a></h3>
<p>These are the videos I've done on GRUB via YouTube:</p>
<ul>
<li>How to Repair Linux With Boot Failure: <a href="https://youtu.be/9D3hvnnby9A">https://youtu.be/9D3hvnnby9A</a></li>
<li>Fix Multi-Boot Systems running GRUB and Windows: <a href="https://youtu.be/3oQfnNhk7qU">https://youtu.be/3oQfnNhk7qU</a></li>
<li>Using SuperGRUBDisk to repair GRUB: <a href="https://youtu.be/gEB6JEYZekE">https://youtu.be/gEB6JEYZekE</a></li>
<li>Custom Bootloader Themes Project: <a href="https://youtu.be/BAyzHP1Cqb0">https://youtu.be/BAyzHP1Cqb0</a></li>
<li>Using GRUB Rescue: <a href="https://youtu.be/r7meKJsjqfY">https://youtu.be/r7meKJsjqfY</a></li>
<li>Using GRUB Customizer for automated GRUB Building: <a href="https://youtu.be/3s7qBJ-H7vw">https://youtu.be/3s7qBJ-H7vw</a></li>
</ul>
<h2 id="systemd-boot---minimal-built-in-boot"><a class="header" href="#systemd-boot---minimal-built-in-boot">Systemd Boot - Minimal Built-In boot</a></h2>
<p>Many distributions are now starting to ship with systemd boot instead of GRUB (PopOS! is one example) and is an interesting boot manager when you don't want a menu or extra packages to boot into your Linux.</p>
<p><em>Note: systemd boot has the capabilities of menus and dual boot, but setting this up is much more cumbersome and why I recommend using GRUB instead of doing this</em></p>
<p>Systemd-boot is also an <em>EFI ONLY</em> bootloader. So if you aren't booted in using UEFI, you can NOT install systemd-boot. Verify that you are in efi mode using <code>ls /sys/firmware/efi</code></p>
<p>Systemd has a dedicated site for documentation. Check it out @ <a href="https://systemd.io/">https://systemd.io/</a> and look at the Booting Section for systemd-boot. Another good source for systemd-boot information is the Arch Wiki @ <a href="https://wiki.archlinux.org/title/systemd-boot">https://wiki.archlinux.org/title/systemd-boot</a></p>
<h3 id="configuraiton"><a class="header" href="#configuraiton">Configuraiton</a></h3>
<p>Here is the directory breakdown for systemd-boot</p>
<ul>
<li>Main Directory: /boot/efi (Sometimes this can be /boot in rare instances and some systems it adds a EFI subdirectory, ex. /boot/efi/EFI)</li>
<li>Configuration files: /boot/efi/loader (General configuration in loader.conf)</li>
<li>OS Entries: /boot/efi/loader/entries (Each .conf is a boot entry)</li>
</ul>
<h4 id="general-configuration"><a class="header" href="#general-configuration">General Configuration</a></h4>
<p>The general configuration will be the loader.conf in the root of the <code>/loader</code> directory. Here is the syntax:</p>
<ul>
<li>default – Default boot option and it can be a wildcard like arch-*.conf.</li>
<li>timeout – menu timeout in seconds before the default entry is booted. If this is not set, the menu will only be shown on key press during boot.</li>
<li>editor – yes is default, but this allows editing boot entries and can be used to reset password or get system level access. Set to no if security is a concern.</li>
<li>auto-entries – shows automatic entries for Windows, EFI Shell, and Default Loader if set to 1 (default), 0 to hide;</li>
<li>auto-firmware – shows entry for rebooting into UEFI firmware settings if set to 1 (default), 0 to hide;</li>
<li>console-mode – changes UEFI console mode:
<ul>
<li>0 for 80x25</li>
<li>1 for 80x50</li>
<li>2 and above for non-standard modes provided by the device firmware</li>
<li>auto picks a suitable mode automatically</li>
<li>max for highest available mode</li>
<li>keep (default) for the firmware selected mode.</li>
</ul>
</li>
</ul>
<p><em>boot/efi/loader/loader.conf</em> example</p>
<pre><code>default  arch.conf
timeout  4
console-mode max
editor   no
</code></pre>
<h4 id="adding-boot-entries"><a class="header" href="#adding-boot-entries">Adding Boot Entries</a></h4>
<p>Every boot entry will be loaded from the <code>/loader/entries</code> directory. Here is that syntax:</p>
<ul>
<li>
<p>title – operating system name. Required.</p>
</li>
<li>
<p>version – kernel version. Optional.</p>
</li>
<li>
<p>machine-id – machine identifier from /etc/machine-id. Optional.</p>
</li>
<li>
<p>efi – EFI program to start. Either this parameter or linux is <em>required</em>.</p>
</li>
<li>
<p>options – space-separated command line options to pass to the EFI program or kernel parameters. <code>root="UUID=3255683f-53a2-4fdf-91cf" OR root="LABEL=OS Label"</code> is required for booting Linux. Here are common options:</p>
<ul>
<li>rw = Read-Write needed for most installs</li>
<li>root = UUID or Label used for identifying the root partition</li>
<li>silent = do NOT display any console output</li>
<li>splash = display OS Splash screen</li>
<li>nomodeset = disable Kernel mode setting. Often needed if using NVIDIA cards and you do not have the drivers installed.</li>
<li>S = run in single mode (often required for resetting root password or modifying root file system)</li>
</ul>
<p>Q: How do you find the UUID?
A: The command <code>sudo blkid</code></p>
<p>_Note: To identify specific drive labels I recommend <code>sudo lsblk</code> which gives a readout of all drives and where they are mounted. When used in conjunction with <code>blkid</code> you will be able to tell what each drive is.</p>
</li>
</ul>
<p>Check all kernel parameters @ <a href="https://www.kernel.org/doc/html/v5.13/admin-guide/kernel-parameters.html">https://www.kernel.org/doc/html/v5.13/admin-guide/kernel-parameters.html</a></p>
<p>Example Arch Linux Entry <code>/boot/efi/loader/entries/arch.conf</code></p>
<pre><code>title   Arch Linux
linux   /vmlinuz-linux
initrd  /intel-ucode.img
initrd  /initramfs-linux.img
options root="LABEL=arch" rw
</code></pre>
<p>Example Windows 10 Entry <code>/boot/efi/loader/entries/win10.conf</code></p>
<pre><code>title Windows 10
efi /EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>Automatic EFI Entry creation with the <code>efibootmgr</code> package - You can check to see what efi options are installed to you with <code>efibootmgr -v</code>.</p>
<pre><code>efibootmgr --create --disk /dev/sda --part 1 --loader "\EFI\systemd\systemd-bootx64.efi" --label "Linux OS" --verbose
</code></pre>
<p><em>Note: This command is used if your Linux EFI system partition is located @ /dev/sda1 and the EFI file located @ /boot/efi/EFI/systemd/systemd-bootx64.efi</em></p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>The default install is very easy once configuration is done. You simply type <code>bootctl install</code> and you are done!</p>
<p>There are configurations with multiple boot partitions, but I do not recommend using systemd-boot for this.</p>
<p>In most instances this will auto update when boot options change, but you can force an update if you manually add more entries with <code>bootctl update</code></p>
<footer id="last-change">Last change: 2025-06-06</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4---server-command-line-interface-mastering-the-terminal"><a class="header" href="#chapter-4---server-command-line-interface-mastering-the-terminal">Chapter 4 - Server Command Line Interface: Mastering the Terminal</a></h1>
<p>This chapter covers the most important aspect of Linux: <strong>the terminal</strong>. The terminal is the beating heart of Linux, enabling you to accomplish virtually anything. For the first eight years I used Linux, I relied exclusively on the terminal, never even considering a graphical interface. The terminal is reliable, quick, and efficient, making it an indispensable tool for Linux users.</p>
<p><strong>Pro Tip:</strong> The terminal is always accessible. If you're stuck on a black screen or graphical interface, press <code>Ctrl + Alt + F2</code> or <code>Ctrl + Alt + F3</code> to switch to a terminal. To return to the graphical interface, press <code>Ctrl + Alt + F7</code>.</p>
<hr />
<h2 id="navigating-the-command-line-interface"><a class="header" href="#navigating-the-command-line-interface">Navigating the Command Line Interface</a></h2>
<h3 id="directory-movement-commands-and-examples"><a class="header" href="#directory-movement-commands-and-examples">Directory Movement Commands and Examples:</a></h3>
<ul>
<li>
<p><code>cd</code> (change directory):</p>
<ul>
<li><code>cd ..</code> (move up a directory)</li>
<li><code>cd name</code> (move into the specified directory)</li>
<li><code>cd /</code> (move to the root directory)</li>
<li><code>cd ~</code> (move to the home directory, e.g., <code>/home/titus</code>)</li>
<li><code>zoxide</code> - A better package for navigating the file system, using fuzzy finding and remembering past directories.</li>
</ul>
</li>
<li>
<p><code>ls</code> (list files):</p>
<ul>
<li><code>ls -a</code> (show all files, including hidden ones)</li>
<li><code>ls -l</code> (long listing format showing permissions)</li>
</ul>
</li>
<li>
<p><code>rm</code> (remove files):</p>
<ul>
<li><code>rm -rf</code> (remove files/directories recursively and forcefully)</li>
<li><code>rmdir</code> (remove empty directories)</li>
<li><code>trash-cli</code> - An alternative to <code>rm</code> that moves files to the trash instead of permanently deleting them.</li>
</ul>
</li>
<li>
<p><code>cp</code> (copy files):</p>
<ul>
<li><code>cp -r</code> (copy files and subdirectories recursively)</li>
<li><code>rsync</code> - A more efficient tool for copying or syncing large amounts of files.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="directory-layout-and-file-system-overview"><a class="header" href="#directory-layout-and-file-system-overview">Directory Layout and File System Overview</a></h3>
<ul>
<li><code>/</code> - Root directory</li>
<li><code>/bin</code> - System executable files</li>
<li><code>/boot</code> - Bootloader files</li>
<li><code>/dev</code> - Device files (requires mounting to browse)</li>
<li><code>/etc</code> - System configuration files</li>
<li><code>/home</code> - User files and configuration files</li>
<li><code>/media</code> - Mounted external media</li>
<li><code>/mnt</code> - Temporary mount points</li>
<li><code>/opt</code> - Optional files</li>
<li><code>/root</code> - Root user files and configurations</li>
<li><code>/tmp</code> - Temporary files</li>
<li><code>/usr</code> - System resources</li>
<li><code>/var</code> - Logs, databases, and other variable data</li>
</ul>
<p>Most interactions with the file system occur within the <code>/home/user</code> directory. This includes configuration files and executable programs. Direct editing of system-wide configuration files in <code>/etc</code> or adding programs to <code>/bin</code> should be done sparingly.</p>
<hr />
<h2 id="system-services-and-configuration"><a class="header" href="#system-services-and-configuration">System Services and Configuration</a></h2>
<p>Modern Linux distributions use an "init system" to control system operations, primarily <strong>systemd</strong>. Systemd manages services, boot processes, networking, and more.</p>
<hr />
<h3 id="controlling-services-and-units"><a class="header" href="#controlling-services-and-units">Controlling Services and Units</a></h3>
<p><code>systemctl</code> is the primary tool for managing services and units in systemd. Units can represent services, device drivers, network mounts, timers (similar to <code>crontab</code>), and more.</p>
<h4 id="common-systemctl-commands"><a class="header" href="#common-systemctl-commands">Common <code>systemctl</code> Commands:</a></h4>
<ul>
<li><code>systemctl status servicename</code> - View the current status of a service.</li>
<li><code>systemctl start servicename</code> - Start a service.</li>
<li><code>systemctl stop servicename</code> - Stop a service.</li>
<li><code>systemctl restart servicename</code> - Restart a service (stop and start).</li>
<li><code>systemctl reload servicename</code> - Reload the configuration file without restarting the service.</li>
<li><code>systemctl enable servicename</code> - Enable a service to start at system boot.</li>
<li><code>systemctl is-enabled servicename</code> - Check if a service is enabled at startup.</li>
<li><code>systemctl is-active servicename</code> - Check if a service is running and active.</li>
<li><code>systemctl list-units</code> - List all running systemd units.</li>
<li><code>systemctl list-units --all</code> - List all units, both active and inactive.</li>
<li><code>systemctl list-units --all --state=inactive</code> - List all inactive units.</li>
<li><code>systemctl list-units --all --type=service</code> - List all units of type "service."</li>
</ul>
<hr />
<h3 id="unit-file-locations"><a class="header" href="#unit-file-locations">Unit File Locations</a></h3>
<p>Systemd unit files are typically located in the following directories:</p>
<ul>
<li><code>/usr/lib/systemd</code> - The main location for system-created unit files.</li>
<li><code>/etc/systemd/system</code> - Contains system-wide unit files, often symbolic links to <code>/usr/lib/systemd</code>. This directory has <strong>top priority</strong> when reading unit files.</li>
<li><code>~/.config/systemd/user/</code> - Contains user-specific unit files. This directory is not created by default and requires the <code>--user</code> option for systemctl commands.</li>
</ul>
<hr />
<h3 id="example-system-unit-file"><a class="header" href="#example-system-unit-file">Example System Unit File</a></h3>
<p>Below is an example of a system unit file:</p>
<pre><code>[Unit]
Description=service_description
After=network.target

[Service]
ExecStart=path_to_executable
Type=forking

[Install]
WantedBy=default.target
</code></pre>
<p>For a full reference, visit: <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">Systemd Unit Documentation</a>.</p>
<hr />
<h3 id="user-based-systemd-services-and-unit-files"><a class="header" href="#user-based-systemd-services-and-unit-files">User-Based Systemd Services and Unit Files</a></h3>
<p>User-specific unit files are stored in the <code>~/.config/systemd/user/</code> directory. These files can be managed using the <code>--user</code> option with <code>systemctl</code>.</p>
<h4 id="example-command"><a class="header" href="#example-command">Example Command:</a></h4>
<pre><code class="language-bash">systemctl --user start usercreatedfile.service
</code></pre>
<p>This command starts a user-created service file located in the user's home directory.</p>
<h4 id="example-user-unit-file"><a class="header" href="#example-user-unit-file">Example User Unit File:</a></h4>
<pre><code>[Unit]
Description=Run service as user
DefaultDependencies=no
After=network.target

[Service]
Type=simple
User=titus
Group=users
ExecStart=/home/titus/scripts/startup_script.sh
TimeoutStartSec=0
RemainAfterExit=yes

[Install]
WantedBy=default.target
</code></pre>
<h3 id="bluetooth-configuration"><a class="header" href="#bluetooth-configuration">Bluetooth Configuration</a></h3>
<p>To configure Bluetooth, you can use the <code>bluetoothctl</code> command-line tool. This tool allows you to manage Bluetooth devices and settings directly from the terminal.</p>
<p>Syntax for <code>bluetoothctl</code> commands:</p>
<pre><code class="language-bash">bluetoothctl [command]
</code></pre>
<h4 id="common-bluetoothctl-commands"><a class="header" href="#common-bluetoothctl-commands">Common <code>bluetoothctl</code> Commands:</a></h4>
<ul>
<li><code>power on</code> - Turn on the Bluetooth adapter.</li>
<li><code>power off</code> - Turn off the Bluetooth adapter.</li>
<li><code>agent on</code> - Enable the agent for pairing.</li>
<li><code>scan on</code> - Start scanning for nearby Bluetooth devices.</li>
<li><code>scan off</code> - Stop scanning for Bluetooth devices.</li>
<li><code>pair &lt;device_address&gt;</code> - Pair with a specific Bluetooth device.</li>
<li><code>connect &lt;device_address&gt;</code> - Connect to a paired Bluetooth device.</li>
<li><code>disconnect &lt;device_address&gt;</code> - Disconnect from a connected Bluetooth device.</li>
<li><code>devices</code> - List all known Bluetooth devices.</li>
<li><code>info &lt;device_address&gt;</code> - Show detailed information about a specific Bluetooth device.</li>
</ul>
<h4 id="example-usage"><a class="header" href="#example-usage">Example Usage:</a></h4>
<pre><code class="language-bash">bluetoothctl
power on
agent on
scan on
</code></pre>
<p>This will turn on the Bluetooth adapter, enable the agent for pairing, and start scanning for nearby Bluetooth devices.</p>
<p><em>Note: <code>blueman</code> is a graphical Bluetooth manager that can be used as an alternative to <code>bluetoothctl</code> for those who prefer a GUI.</em></p>
<h3 id="audio-configuration"><a class="header" href="#audio-configuration">Audio Configuration</a></h3>
<p>Linux provides several command-line tools for managing audio. The two main sound systems are ALSA (Advanced Linux Sound Architecture) and PulseAudio, with PulseAudio running on top of ALSA.</p>
<h4 id="pulseaudio-commands-pactl"><a class="header" href="#pulseaudio-commands-pactl">PulseAudio Commands (<code>pactl</code>)</a></h4>
<p>The <code>pactl</code> command is used to control the PulseAudio sound server:</p>
<pre><code class="language-bash"># List audio sources and sinks
pactl list sources        # List input devices
pactl list sinks         # List output devices

# Volume control
pactl set-sink-volume @DEFAULT_SINK@ 50%     # Set volume to 50%
pactl set-sink-mute @DEFAULT_SINK@ toggle    # Toggle mute

# List loaded modules
pactl list modules
</code></pre>
<h4 id="alsa-mixer-alsamixer"><a class="header" href="#alsa-mixer-alsamixer">ALSA Mixer (<code>alsamixer</code>)</a></h4>
<p><code>alsamixer</code> is a terminal-based mixer program for ALSA:</p>
<pre><code class="language-bash">alsamixer    # Open the mixer interface
</code></pre>
<p>Navigation in <code>alsamixer</code>:</p>
<ul>
<li>Arrow keys: Navigate between channels</li>
<li>Up/Down: Adjust volume</li>
<li>M: Toggle mute</li>
<li>F6: Select sound card</li>
<li>Esc: Exit</li>
</ul>
<h4 id="common-audio-troubleshooting-commands"><a class="header" href="#common-audio-troubleshooting-commands">Common Audio Troubleshooting Commands</a></h4>
<pre><code class="language-bash"># Restart PulseAudio
pulseaudio -k        # Kill the PulseAudio daemon
pulseaudio --start   # Start PulseAudio

# Check audio devices
aplay -l             # List all ALSA playback devices
arecord -l          # List all ALSA recording devices

# Test audio output
speaker-test -c 2    # Test stereo speakers
</code></pre>
<h4 id="audio-device-management-with-pavucontrol"><a class="header" href="#audio-device-management-with-pavucontrol">Audio Device Management with <code>pavucontrol</code></a></h4>
<p>While <code>pavucontrol</code> is technically a GUI application, it can be installed and launched from the terminal:</p>
<pre><code class="language-bash">sudo apt install pavucontrol   # Install on Debian/Ubuntu
pavucontrol                    # Launch the control interface
</code></pre>
<h4 id="pipewire-audio-system"><a class="header" href="#pipewire-audio-system">Pipewire Audio System</a></h4>
<p>Pipewire is the modern replacement for both PulseAudio and JACK. It maintains compatibility with PulseAudio clients, so <code>pactl</code> commands work with Pipewire. Additionally, Pipewire provides its own tools:</p>
<pre><code class="language-bash"># Check Pipewire status
pw-cli status
pw-top                # Show real-time audio processing graph

# List audio devices
pw-dump               # Detailed info about audio devices and nodes
pw-cli list-objects   # List all Pipewire objects

# Control specific nodes
pw-cli node-id        # Get ID of audio nodes
pw-metadata -n settings 0 clock.force-rate 48000  # Set sample rate

# Monitor audio
pw-mon               # Monitor Pipewire events in real-time
</code></pre>
<p>You can still use PulseAudio tools with Pipewire:</p>
<ul>
<li><code>pactl</code> commands work as shown above</li>
<li><code>pavucontrol</code> works normally</li>
<li>ALSA applications work without modification</li>
</ul>
<p><em>Note: Most modern Linux distributions are transitioning to Pipewire as their default audio system due to its improved latency, Bluetooth handling, and compatibility with both PulseAudio and JACK applications.</em></p>
<h5 id="typical-pipewire-package-names"><a class="header" href="#typical-pipewire-package-names">Typical Pipewire Package Names:</a></h5>
<ul>
<li><code>pipewire</code> - Core Pipewire package</li>
<li><code>pipewire-pulse</code> - PulseAudio compatibility layer</li>
<li><code>pipewire-jack</code> - JACK compatibility layer</li>
<li><code>pipewire-alsa</code> - ALSA compatibility layer</li>
<li><code>wireplumber</code> - Session manager for Pipewire</li>
</ul>
<p><em>Note: Do NOT use pipewire-media-session, as it is deprecated and replaced by wireplumber.</em></p>
<footer id="last-change">Last change: 2025-06-04</footer><div style="break-before: page; page-break-before: always;"></div><h2 id="chapter-5-drives-and-filesystems"><a class="header" href="#chapter-5-drives-and-filesystems">Chapter 5: Drives and Filesystems</a></h2>
<p>This chapter focuses on managing drives and filesystems in Linux, including mounting and unmounting drives, understanding filesystems, and using tools like <code>fdisk</code>, <code>mkfs</code>, and <code>fsck</code>.</p>
<h3 id="understanding-drives-and-filesystems"><a class="header" href="#understanding-drives-and-filesystems">Understanding Drives and Filesystems</a></h3>
<p>In Linux, drives and filesystems are fundamental components that allow the operating system to store and retrieve data. Each drive can have one or more partitions, and each partition can be formatted with a specific filesystem type.</p>
<h4 id="common-filesystem-types"><a class="header" href="#common-filesystem-types">Common Filesystem Types</a></h4>
<ul>
<li><strong>ext4</strong>: The most common filesystem for Linux, known for its performance and reliability.</li>
<li><strong>xfs</strong>: A high-performance filesystem often used for large files and high-capacity storage.</li>
<li><strong>btrfs</strong>: A modern filesystem with advanced features like snapshots and dynamic resizing.</li>
<li><strong>vfat</strong>: A filesystem compatible with Windows, often used for USB drives, external storage, and EFI boot partitions.</li>
<li><strong>ntfs</strong>: The Windows NT filesystem, used for compatibility with Windows systems.</li>
<li><strong>swap</strong>: A special filesystem used for swap space, which is used when the system runs out of RAM.</li>
</ul>
<p>Personally, I use <code>ext4</code> for most of my drives, <code>xfs</code> for large data storage, and <code>vfat</code> for USB drives and EFI partitions. I avoid <code>btrfs</code> due to its complexity and potential issues with data integrity, although it has improved significantly in recent years. If you are interested in using <code>btrfs</code> check out this article and video I wrote about it: <a href="https://christitus.com/btrfs-guide/">https://christitus.com/btrfs-guide/</a>. The biggest advantage of <code>btrfs</code> is its ability to take snapshots, which can be useful for backups and system recovery. However, it requires more advanced knowledge to manage effectively.</p>
<h4 id="drive-management-tools"><a class="header" href="#drive-management-tools">Drive Management Tools</a></h4>
<ul>
<li><strong>fdisk</strong>: A command-line utility for managing disk partitions. It allows you to create, delete, and modify partitions on a disk.</li>
<li><strong>parted</strong>: A more advanced command-line utility for managing disk partitions, supporting larger disks and more complex partitioning schemes.</li>
<li><strong>lsblk</strong>: A command-line utility that lists block devices, including drives and partitions, along with their mount points and filesystem types.</li>
<li><strong>blkid</strong>: A command-line utility that displays information about block devices, including their UUIDs and filesystem types.</li>
<li><strong>df</strong>: A command-line utility that displays disk space usage for mounted filesystems.</li>
<li><strong>du</strong>: A command-line utility that estimates file and directory space usage.</li>
<li><strong>mount</strong>: A command-line utility that mounts filesystems to specific directories, allowing access to the data stored on those filesystems.</li>
<li><strong>umount</strong>: A command-line utility that unmounts filesystems, making them inaccessible until remounted.</li>
<li><strong>mkfs</strong>: A command-line utility that creates a filesystem on a partition or disk.</li>
<li><strong>fsck</strong>: A command-line utility that checks and repairs filesystems for errors.</li>
<li><strong>lsusb</strong>: A command-line utility that lists USB devices connected to the system, useful for identifying external drives and other USB peripherals.</li>
<li><strong>lspci</strong>: A command-line utility that lists PCI devices, including internal drives and controllers.</li>
<li><strong>smartctl</strong>: A command-line utility that monitors the health of hard drives and SSDs using S.M.A.R.T. (Self-Monitoring, Analysis, and Reporting Technology) data.</li>
<li><strong>hdparm</strong>: A command-line utility that allows you to configure and manage hard drives, including setting power management options and testing drive performance.</li>
<li><strong>gparted</strong>: A graphical partition editor that allows you to create, delete, and modify partitions on a disk using a user-friendly interface.</li>
</ul>
<h3 id="mounting-and-unmounting-drives"><a class="header" href="#mounting-and-unmounting-drives">Mounting and Unmounting Drives</a></h3>
<p>Mounting and unmounting drives is a common task in Linux, especially when dealing with external storage devices or network shares.</p>
<p>Mount commands:</p>
<pre><code class="language-bash"># Mount a filesystem
sudo mount /dev/sdX1 /mnt/mydrive
# Unmount a filesystem
sudo umount /mnt/mydrive
</code></pre>
<h4 id="mounting-drives"><a class="header" href="#mounting-drives">Mounting Drives</a></h4>
<p>To mount a drive, you need to specify the device (e.g., <code>/dev/sda1</code>) and the mount point (e.g., <code>/mnt/mydrive</code>). The mount point is a directory where the contents of the drive will be accessible.
You can also specify the filesystem type and mount options if needed. For example, to mount an ext4 filesystem with read-write permissions, you can use:</p>
<pre><code class="language-bash">sudo mount -t ext4 -o rw /dev/sdX1 /mnt/mydrive
</code></pre>
<p>Where <code>-t</code> specifies the filesystem type and <code>-o</code> specifies mount options.</p>
<h4 id="unmounting-drives"><a class="header" href="#unmounting-drives">Unmounting Drives</a></h4>
<p>To unmount a drive, you can use the <code>umount</code> command followed by the mount point or device name. For example:</p>
<pre><code class="language-bash">sudo umount /mnt/mydrive
</code></pre>
<p>If the drive is busy or in use, you may need to close any open files or processes using it before unmounting. You can also use the <code>-l</code> option to perform a lazy unmount, which detaches the filesystem but allows it to be cleaned up later:</p>
<pre><code class="language-bash">sudo umount -l /mnt/mydrive
</code></pre>
<h3 id="filesystem-management"><a class="header" href="#filesystem-management">Filesystem Management</a></h3>
<p>Managing filesystems in Linux involves creating, formatting, and checking filesystems on drives and partitions. This section covers the essential commands and tools for filesystem management.</p>
<h4 id="creating-filesystems"><a class="header" href="#creating-filesystems">Creating Filesystems</a></h4>
<p><strong>WARNING: Creating a filesystem will erase and format all data on the partition. Ensure you have backups of any important data before proceeding.</strong></p>
<p>To create a filesystem on a partition, you can use the <code>mkfs</code> command followed by the filesystem type and the device name. For example, to create an ext4 filesystem on <code>/dev/sdX1</code>, you can use:</p>
<pre><code class="language-bash">sudo mkfs.ext4 /dev/sdX1
</code></pre>
<p>You can also specify other filesystem types, such as <code>mkfs.xfs</code> for XFS or <code>mkfs.fat -F 32</code> for FAT32. For example:</p>
<pre><code class="language-bash">sudo mkfs.xfs /dev/sdX1
sudo mkfs.fat -F 32 /dev/sdX1
</code></pre>
<p><em>Note: When dealing with EFI System Partitions (ESP), I recommend referring to the this docuumentation: <a href="https://wiki.archlinux.org/title/EFI_system_partition">https://wiki.archlinux.org/title/EFI_system_partition</a> for the most up-to-date information on creating and managing ESPs.</em></p>
<h4 id="checking-filesystems"><a class="header" href="#checking-filesystems">Checking Filesystems</a></h4>
<p>To check a filesystem for errors, you can use the <code>fsck</code> command followed by the device name. For example, to check an ext4 filesystem on <code>/dev/sdX1</code>, you can use:</p>
<pre><code class="language-bash">sudo fsck.ext4 /dev/sdX1
</code></pre>
<p>If you want to automatically fix errors, you can use the <code>-y</code> option:</p>
<pre><code class="language-bash">sudo fsck.ext4 -y /dev/sdX1
</code></pre>
<h4 id="viewing-filesystem-information"><a class="header" href="#viewing-filesystem-information">Viewing Filesystem Information</a></h4>
<p>To view information about filesystems, you can use the <code>df</code> command, which displays disk space usage for mounted filesystems. For example:</p>
<pre><code class="language-bash">df -h
</code></pre>
<p>This command shows the disk space usage in a human-readable format, including the total size, used space, available space, and mount points for each filesystem.</p>
<h4 id="fstab-configuration"><a class="header" href="#fstab-configuration">Fstab Configuration</a></h4>
<p>The <code>/etc/fstab</code> file is used to define how disk partitions, network shares, and other file systems are mounted at boot time. Each line in the file represents a file system and its mount options.</p>
<p>Fstab structure:</p>
<ul>
<li>Device: usually the given name or UUID of the mounted device (sda1/sda2/etc).</li>
<li>Mount Point: designates the directory where the device is/will be mounted.</li>
<li>File System Type: nothing trick here, shows the type of filesystem in use.
Options: lists any active mount options. If using multiple options they must be separated by commas.</li>
<li>Backup Operation: (the first digit) this is a binary system where 1 = dump utility backup of a partition. 0 = no backup. This is an outdated backup method and should <strong>NOT</strong> be used.</li>
<li>File System Check Order: (second digit) Here we can see three possible outcomes.  0 means that fsck will not check the filesystem. Numbers higher than this represent the check order. The root filesystem should be set to 1 and other partitions set to 2.</li>
</ul>
<p>Stntax:</p>
<pre><code># &lt;device&gt; &lt;mount point&gt; &lt;file system type&gt; &lt;options&gt; &lt;backup operation&gt; &lt;fsck order&gt;
</code></pre>
<p>Example:</p>
<pre><code>UUID=1234-5678 /mnt/data  ext4 defaults 0 2
/dev/sdb1      /media/usb vfat defaults,nofail 0 0
</code></pre>
<p>Options:</p>
<ul>
<li><code>defaults</code>: Use default mount options.</li>
<li><code>nofail</code>: Ignore errors when mounting the filesystem.</li>
<li><code>noauto</code>: Do not mount automatically at boot.</li>
<li><code>user</code>: Allow non-root users to mount the filesystem.</li>
<li><code>rw</code>: Mount the filesystem as read-write.</li>
<li><code>ro</code>: Mount the filesystem as read-only.</li>
<li><code>exec</code>: Allow execution of binaries on the filesystem.</li>
<li><code>noexec</code>: Prevent execution of binaries on the filesystem.</li>
<li><code>sync</code>: All I/O operations are done synchronously.</li>
<li><code>async</code>: All I/O operations are done asynchronously.</li>
<li><code>uid=1000</code>: Set the owner of the mounted filesystem to user ID 1000.</li>
<li><code>gid=1000</code>: Set the group of the mounted filesystem to group ID 1000.</li>
<li><code>umask=022</code>: Set the default permissions for files and directories on the mounted filesystem.</li>
<li><code>dmask=027</code>: Set the default permissions for directories on the mounted filesystem.</li>
<li><code>fmask=133</code>: Set the default permissions for files on the mounted filesystem.</li>
</ul>
<p>My fstab file with NFS mounts and multiple drives:</p>
<pre><code># Static information about the filesystems.
# See fstab(5) for details.

# &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;
# /dev/nvme1n1p2
UUID=1188f001-7a26-4d75-819f-202e4ef2da96	/         	ext4      	rw,relatime	0 1

# /dev/nvme1n1p1
UUID=3337-A669      	/boot     	vfat      	rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro	0 2

# /dev/nvme1n1p3
UUID=df8df26b-3bdc-427d-be86-43d6a25208b4	/home     	ext4      	rw,relatime	0 2

# Network Drives
10.0.0.2:/volume2/Images		/media/images	nfs	x-systemd.after=network-online.target,x-systemd.automount,x-systemd.mount-timeout=90,_netdev 0 0
</code></pre>
<footer id="last-change">Last change: 2025-06-15</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="linux-hardware-compatibility"><a class="header" href="#linux-hardware-compatibility">Linux Hardware Compatibility</a></h1>
<p>The biggest myth told by the Linux community is that Linux works on all hardware. This is not true, and it is a common misconception that leads to many users being disappointed when they try to install Linux on their machines. The reality is that while Linux supports a wide range of hardware, there are still many devices that do not work well or at all with Linux.</p>
<h2 id="incompatible-hardware"><a class="header" href="#incompatible-hardware">Incompatible Hardware</a></h2>
<p>Some hardware is simply not compatible with Linux. This can be due to a lack of drivers, proprietary firmware, or other issues. For example, some Wi-Fi adapters, graphics cards, and printers may not work properly on Linux. Before installing Linux, it is essential to check the compatibility of your hardware.</p>
<p>Hardware I've personally had issues with includes:</p>
<ul>
<li><strong>NVIDIA Graphics Cards</strong>: While NVIDIA provides proprietary drivers for Linux, they can be difficult to install and may not work with all distributions. Open-source alternatives like Nouveau exist but often lack performance and features. This is getting better with each kernel release, and nVidia open sourcing their drives, but still is a common issue. I've had issues with obscure Wayland configurations, Custom Linux Kernels, and certain desktop environments that do not play well with NVIDIA drivers. AMD graphics is still the best option for Linux users by a large margin. Keep an eye on the official NVIDIA open source drivers with the package <code>nvidia-open</code> for your distribution, as they are improving over time. Arch Linux users will be the first to see these improvements, as they are the first to implement new features. Debian and Ubuntu users typically see these improvements about 6 months later, and Fedora users about 3 months later. However, LTS releases will take longer to update.</li>
<li><strong>Broadcom Wi-Fi Adapters</strong>: Many Broadcom Wi-Fi adapters require proprietary drivers that are not included in the Linux kernel by default. This can lead to connectivity issues.</li>
<li><strong>Certain Printers</strong>: Some printers, especially those from manufacturers like HP and Canon, may not have Linux drivers available or may require additional configuration to work correctly.</li>
<li><strong>Fingerprint Readers</strong>: Many fingerprint readers do not have Linux support, making them unusable for authentication purposes.</li>
<li><strong>Webcams</strong>: Some webcams, particularly older models, may not be recognized by Linux or may require additional drivers to function correctly.</li>
<li><strong>Bluetooth Adapters</strong>: Some Bluetooth adapters may not work out of the box and require additional drivers or configuration.</li>
<li><strong>Touchpads</strong>: Some touchpads, especially those with advanced features, may not work correctly without additional configuration or drivers.</li>
<li><strong>Audio Devices</strong>: Some audio devices, particularly those with proprietary drivers, may not work correctly on Linux.</li>
<li><strong>Gaming Peripherals</strong>: Many gaming mice and keyboards may not have full functionality on Linux, especially those with customizable features.</li>
<li><strong>Virtual Reality Headsets</strong>: Many VR headsets do not have Linux support, making them unusable for gaming or other applications.</li>
</ul>
<h2 id="checking-compatibility"><a class="header" href="#checking-compatibility">Checking Compatibility</a></h2>
<p>Before installing Linux, it is crucial to check the compatibility of your hardware. Here are some resources to help you determine if your hardware is compatible with Linux:</p>
<ul>
<li><strong>Linux Hardware Compatibility Lists</strong>: Websites like <a href="https://linux-hardware.org/">Linux Hardware</a> provide lists of hardware that is known to work well with Linux.</li>
<li><strong>Distribution-Specific Compatibility Lists</strong>: Many Linux distributions maintain their own hardware compatibility lists. For example, <a href="https://wiki.ubuntu.com/HardwareSupport">Ubuntu's Hardware Compatibility</a> page provides information on supported devices.</li>
<li><strong>Forums and Communities</strong>: Online forums and communities, such as the <a href="https://www.linuxquestions.org/">LinuxQuestions.org</a> or the <a href="https://www.reddit.com/r/linux4noobs/">Linux 4 Noobs Subreddit</a>, can be valuable resources for checking hardware compatibility. Users often share their experiences with specific hardware and Linux distributions.</li>
<li><strong>Manufacturer Websites</strong>: Some hardware manufacturers provide information on Linux compatibility for their products. Check the manufacturer's website for any available drivers or support documentation.</li>
<li><strong>Distro-Specific Tools</strong>: Some Linux distributions come with tools that can help you check hardware compatibility. <code>lshw</code> (List Hardware) is a command-line utility that provides detailed information about your system's hardware. You can use it to check if your hardware is recognized by the Linux kernel.</li>
<li><strong>Live USB Testing</strong>: Before installing Linux, you can create a live USB of the distribution you want to try. Booting from the live USB allows you to test hardware compatibility without making any changes to your system. This is a great way to see if your hardware works well with Linux before committing to an installation.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>While Linux supports a wide range of hardware, it is essential to be aware of potential compatibility issues. Before installing Linux, check the compatibility of your hardware using the resources mentioned above. By doing so, you can avoid disappointment and ensure a smooth installation and usage experience with Linux.</p>
<footer id="last-change">Last change: 2025-06-15</footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
