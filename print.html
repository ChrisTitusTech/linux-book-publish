<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Linux Desktop Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/last-changed.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "frappe";
        </script>

        <!-- Custom JS scripts for mdbook-pdf PDF generation -->
        <script type='text/javascript'>
            let markAllContentHasLoadedForPrinting = () =>
                window.setTimeout(
                    () => {
                        let p = document.createElement('div');
                        p.setAttribute('id', 'content-has-all-loaded-for-mdbook-pdf-generation');
                        document.body.appendChild(p);
                    }, 100
                );

            window.addEventListener('load', () => {
                // Expand all the <details> elements for printing.
                r = document.getElementsByTagName('details');
                for (let i of r)
                    i.open = true;

                try {
                    MathJax.Hub.Register.StartupHook('End', markAllContentHasLoadedForPrinting);
                } catch (e) {
                    markAllContentHasLoadedForPrinting();
                }
            });
        </script>
    <div style="display: none"><a href="#foreward">foreward</a><a href="#chapter1-whylinux">chapter1-whylinux</a><a href="#chapter2-linuxmadeof">chapter2-linuxmadeof</a><a href="#chapter3-bootloaders">chapter3-bootloaders</a><a href="#chapter4-servercli">chapter4-servercli</a><a href="#chapter5-drives">chapter5-drives</a><a href="#chapter6-hardware">chapter6-hardware</a><a href="#chapter7-linuxprograms">chapter7-linuxprograms</a></div>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Linux Desktop Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreward"><a class="header" href="#foreward">Foreward</a></h1>
<p>This book was created to enable anyone to install and use Linux effectively. Its creation was made possible thanks to the help and support of the Chris Titus Tech community. The information contained in this book is drawn from thousands of comments, research, and real-world experiences from users who utilize Linux as their daily driver.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://christitus.com">Official Website</a></li>
<li><a href="https://github.com/ChrisTitusTech">GitHub Projects</a></li>
<li><a href="https://www.youtube.com/c/ChrisTitusTech">YouTube Tutorials</a></li>
<li><a href="https://cttstore.com">Digital Downloads</a></li>
</ul>
<h2 id="special-features-of-this-book"><a class="header" href="#special-features-of-this-book">Special Features of This Book</a></h2>
<p>Throughout this book, you will find links to videos designed to enhance the learning experience. Some concepts are better demonstrated visually than explained in text, and these resources will help you better understand the topics discussed. This book serves as a guide to accelerate your learning, allowing you to absorb knowledge efficiently without needing to watch hundreds of hours of videos.</p>
<h2 id="before-you-begin"><a class="header" href="#before-you-begin">Before you Begin</a></h2>
<p>Before diving into the content, understand that Linux works very differently from Windows or macOS. It is not just a different operating system; it is a different way of thinking about how computers work. This book will help you transition to this new mindset, but it will take time to adjust. Be patient with yourself and embrace the learning process.</p>
<p>Also, when referring to ANY resources the date of the resource is important. This book is designed to be a living document, meaning it will be updated with new information and resources as they become available. Always check the date of the resources you are using to ensure they are still relevant and accurate. Linux moves quickly, and what was true yesterday may not be true today. This book will help you stay up-to-date with the latest information and resources available, but check the last updated date on the resources you are using to ensure they are still relevant and accurate. Each chapter will have a last updated date at the end of the chapter, and you can find the latest version of this book at <a href="https://thelinuxbook.com">https://thelinuxbook.com</a>.</p>
<footer id="last-change">Last change: 2025-06-15</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="starting-linux"><a class="header" href="#starting-linux">Starting Linux</a></h1>
<ul>
<li><a href="chapter1-whylinux.html#distributions">Distributions</a>
<ul>
<li><a href="chapter1-whylinux.html#debian-based-distributions">Debian-Based Distributions</a></li>
<li><a href="chapter1-whylinux.html#rhel-based-distributions">RHEL-Based Distributions</a></li>
<li><a href="chapter1-whylinux.html#arch-based-distributions">Arch-Based Distributions</a></li>
</ul>
</li>
<li><a href="chapter1-whylinux.html#release-types">Release Types</a>
<ul>
<li><a href="chapter1-whylinux.html#rolling-release">Rolling Release</a></li>
<li><a href="chapter1-whylinux.html#stable-lts-release">Stable LTS Release</a></li>
</ul>
</li>
<li><a href="chapter1-whylinux.html#modularity">Modularity</a></li>
<li><a href="chapter1-whylinux.html#what-distribution-should-you-use">What Distribution Should You Use</a>
<ul>
<li><a href="chapter1-whylinux.html#tips-for-choosing-a-distribution">Tips for Choosing a Distribution</a></li>
<li><a href="chapter1-whylinux.html#useful-links">Useful Links</a></li>
</ul>
</li>
</ul>
<p>Linux is a powerful and versatile operating system that gives you complete control over your computer. Whether you're looking for stability, security, or customization, Linux has something to offer for everyone. In this chapter, we'll explore the basics of Linux, including its distributions, release types, and modularity.</p>
<p>Why Choose Linux over Windows or MacOS?: <a href="https://links.thelinuxbook.com/whychooselinux">https://links.thelinuxbook.com/whychooselinux</a></p>
<h2 id="distributions"><a class="header" href="#distributions">Distributions</a></h2>
<p>Linux by itself doesn't include programs and things to make a fully function computer. So we have Linux distributions. There are many Distributions, in fact, hundreds of them that can be rather confusing. However there are three main branches that comprise the most amount of users and will be the focus of this book.</p>
<p>Overview of All Distributions on Linux: <a href="https://links.thelinuxbook.com/alldistros">https://links.thelinuxbook.com/alldistros</a></p>
<h3 id="debian-based-distributions"><a class="header" href="#debian-based-distributions">Debian-Based Distributions</a></h3>
<p>These are the majority of Linux users and most online guides are written with them in mind. They typically are very stable and long term support. When you hear Ubuntu, Linux Mint, Pop OS, Elementary OS, KDE Neon, Peppermint, and much more... they are all based around Debian. This means how you install programs and the package manger is all the same. This is typically where most users start from. Anytime you see the command <em>apt install</em> or <em>.deb</em> package the installation instructions are geared for a this distribution branch.</p>
<h3 id="rhel-based-distributions"><a class="header" href="#rhel-based-distributions">RHEL-Based Distributions</a></h3>
<p>RedHat Enterprise Linux is what RHEL stands for. This is the backbone of many Linux servers as any RHEL based distribution is built with security and stability in mind. There are 3 distributions that most think of when it comes to the RHEL category. RedHat Enterprise Linux (Subscription-Based), CentOS (RHEL clone but no subscription), and Fedora. The package manager for these distributions is <em>dnf install</em> or <em>yum install</em> and utilizing the <em>.rpm</em> packages you download from sites.</p>
<h3 id="arch-based-distributions"><a class="header" href="#arch-based-distributions">Arch-Based Distributions</a></h3>
<p>Arch Linux is a user created distribution that isn't backed by any company and has some unique features as a result. The main distributions you hear about in this category are Arch Linux and Manjaro. It's package manager syntax looks like <em>pacman -S packagename</em> and doesn't have downloadable packages like Debian or RHEL distros. It does however have a unique feature called the AUR (Arch User Repository) and is able to build programs on the fly. While this is incredibly powerful, it can also be dangerous as these aren't vetted and sometimes have old packages that are out of date. So if using the AUR always check the site to make sure it is up to date and is a legitimate source.</p>
<div class="table-wrapper"><table><thead><tr><th>Distribution Type</th><th>Examples</th><th>Package Manager Syntax</th><th>Key Features</th></tr></thead><tbody>
<tr><td>Debian-Based</td><td>Ubuntu, Linux Mint, Pop OS</td><td><code>apt install</code></td><td>Stable, beginner-friendly</td></tr>
<tr><td>RHEL-Based</td><td>CentOS, Fedora</td><td><code>dnf install</code> / <code>yum install</code></td><td>Secure, server-focused</td></tr>
<tr><td>Arch-Based</td><td>Arch Linux, Manjaro</td><td><code>pacman -S</code></td><td>Rolling release, highly customizable</td></tr>
</tbody></table>
</div>
<h2 id="release-types"><a class="header" href="#release-types">Release Types</a></h2>
<p>Lets go over the two types of distribution releases you will encounter Rolling and Stable. Both have their pros and cons, but depending on how you use your PC one might better than the other for you.</p>
<p>LTS vs Rolling Release: <a href="https://links.thelinuxbook.com/ltsvsrolling">https://links.thelinuxbook.com/ltsvsrolling</a></p>
<h3 id="rolling-release"><a class="header" href="#rolling-release">Rolling Release</a></h3>
<p>Arch Linux is what is called a rolling release, which is a version of Linux that isn't tied to a single version of the Linux kernel. By comparison, Ubuntu does 6 month releases where it will not update major system components. Arch can update the Linux kernel and other core system components every week or everyday in some instances. This is a double edged sword, as you get the latest and greatest features, but you are also prone to more bugs.</p>
<h3 id="stable-lts-release"><a class="header" href="#stable-lts-release">Stable LTS Release</a></h3>
<p>Debian and RHEL based distributions are typically using a proven release cycle. Each distribution can have different release schedules and vary from a couple months to several years. The distributions that are specifically called LTS (Long Term Support) are made with longevity in mind. The support structure can range from 5 years (Ubuntu LTS) to 10 Years (CentOS Versions). The downside to using stable releases is the packages are sometimes considered old and are not as up to date. However, these versions will run for years and are extremely stable.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>The power of Linux is that no matter what distribution you choose, it is modular. You can modify and make massive changes to drastically change the user experience. This gives you the power to make Linux operate how ever you see fit and you are the only thing holding it back.</p>
<p>Linux's modularity allows you to tailor your system to your needs. Whether you're building a lightweight system for an old laptop or a high-performance gaming rig, Linux gives you the tools to make it happen. Here are some examples:</p>
<ul>
<li><strong>Server Setup:</strong> Install only essential server packages and skip the desktop environment.</li>
<li><strong>Lightweight Desktop:</strong> Use LXDE or XFCE for older hardware.</li>
<li><strong>Gaming System:</strong> Install Steam, Proton, and GPU drivers for a complete gaming experience.</li>
</ul>
<h2 id="what-distribution-should-you-use"><a class="header" href="#what-distribution-should-you-use">What Distribution Should You Use</a></h2>
<p>I don't consider Linux complex, but more of a rabbit hole of infinite possibilities. This is very overwhelming for a new user and often misunderstood. That is why I always recommend popular distributions with widespread support and resembling the operating system they are coming from. For Windows Users, I recommend starting with Linux Mint and for MacOS users I recommend Pop OS! as it has more Mac feel out of the box.</p>
<h3 id="tips-for-choosing-a-distribution"><a class="header" href="#tips-for-choosing-a-distribution">Tips for Choosing a Distribution</a></h3>
<ul>
<li><strong>Windows Users:</strong> Start with Linux Mint for a familiar experience.</li>
<li><strong>MacOS Users:</strong> Try Pop OS for a sleek and modern interface.</li>
<li><strong>New Gaming Users:</strong> Bazzite gives an controlled environment with lots of gaming support by default. System shouldn't be</li>
<li><strong>Advanced Gaming Users:</strong> Nobara is made by Glorius Eggroll and is a gaming focused distribution with many tweaks and optimizations for gaming out of the box. It also allows for lots of system customization.</li>
<li><strong>Advanced Users:</strong> Explore Arch Linux or Fedora for more control and cutting-edge features.</li>
</ul>
<h3 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h3>
<ul>
<li>Linux Mint Official Site - <a href="https://linuxmint.com">https://linuxmint.com</a></li>
<li>Pop OS Official Site - <a href="https://pop.system76.com">https://pop.system76.com</a></li>
<li>Bazzite Official Site - <a href="https://bazzite.gg">https://bazzite.gg</a></li>
<li>Nobara Official Site - <a href="https://nobaraproject.org">https://nobaraproject.org</a></li>
<li>Arch Linux Wiki - <a href="https://wiki.archlinux.org">https://wiki.archlinux.org</a></li>
</ul>
<footer id="last-change">Last change: 2025-06-17</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-linux-distribution-made-of"><a class="header" href="#what-is-a-linux-distribution-made-of">What is a Linux Distribution Made of?</a></h1>
<ul>
<li><a href="chapter2-linuxmadeof.html#bootloader">Bootloader</a></li>
<li><a href="chapter2-linuxmadeof.html#display-renderer">Display Renderer</a></li>
<li><a href="chapter2-linuxmadeof.html#display-manager">Display Manager</a>
<ul>
<li><a href="chapter2-linuxmadeof.html#sddm">SDDM</a></li>
<li><a href="chapter2-linuxmadeof.html#gdm">GDM</a></li>
<li><a href="chapter2-linuxmadeof.html#lightdm">LightDM</a></li>
<li><a href="chapter2-linuxmadeof.html#none">None</a></li>
</ul>
</li>
<li><a href="chapter2-linuxmadeof.html#desktop-environments">Desktop Environments</a>
<ul>
<li><a href="chapter2-linuxmadeof.html#kde">KDE</a></li>
<li><a href="chapter2-linuxmadeof.html#gnome">GNOME</a></li>
<li><a href="chapter2-linuxmadeof.html#cinnamon">Cinnamon</a></li>
<li><a href="chapter2-linuxmadeof.html#mate">MATE</a></li>
<li><a href="chapter2-linuxmadeof.html#xfce">XFCE</a></li>
<li><a href="chapter2-linuxmadeof.html#lxqt--lxde">LXQt / LXDE</a></li>
<li><a href="chapter2-linuxmadeof.html#deepin">Deepin</a></li>
<li><a href="chapter2-linuxmadeof.html#others">Others</a></li>
</ul>
</li>
<li><a href="chapter2-linuxmadeof.html#window-managers">Window Managers</a></li>
<li><a href="chapter2-linuxmadeof.html#package-manager">Package Manager</a>
<ul>
<li><a href="chapter2-linuxmadeof.html#apt">APT</a></li>
<li><a href="chapter2-linuxmadeof.html#dnf--yum">DNF / YUM</a></li>
<li><a href="chapter2-linuxmadeof.html#pacman">Pacman</a></li>
<li><a href="chapter2-linuxmadeof.html#others-1">Others</a></li>
<li><a href="chapter2-linuxmadeof.html#flatpak--appimage--snapd">Flatpak / AppImage / SnapD</a></li>
<li><a href="chapter2-linuxmadeof.html#misconceptions">Misconceptions</a></li>
</ul>
</li>
<li><a href="chapter2-linuxmadeof.html#types-of-linux-installations">Types of Linux Installations</a>
<ul>
<li><a href="chapter2-linuxmadeof.html#beginner-installation">Beginner Installation</a></li>
<li><a href="chapter2-linuxmadeof.html#intermediate-installation">Intermediate Installation</a></li>
<li><a href="chapter2-linuxmadeof.html#expert-installation">Expert Installation</a></li>
</ul>
</li>
<li><a href="chapter2-linuxmadeof.html#progression">Progression</a></li>
</ul>
<p>A Linux distribution comprises the same components that make up any operating system. Every Linux distribution has the following components, many of which can be customized to great effect. This is why there are so many options in Linux. With that in mind, here are the components of Linux:</p>
<h2 id="bootloader"><a class="header" href="#bootloader">Bootloader</a></h2>
<p>The bootloader is what boots the machine. There are two types of boot processes for any operating system: EFI and Legacy boot. Most Linux distributions use a package called <em>GRUB</em> to handle this process. However, some newer distributions have started using <em>systemd-boot</em> instead of GRUB.</p>
<h2 id="display-renderer"><a class="header" href="#display-renderer">Display Renderer</a></h2>
<p>For graphical elements to appear on the screen, either Xorg or Wayland is required to render the graphics. Both have their pros and cons. Xorg has been around since the beginning and is feature-rich, but its structure is messy. Wayland is newer and offers cleaner code. Personally, I use Xorg on most distributions because it does everything I need. However, most Linux distributions going forward will package Wayland by default and Xorg will eventually go away. Most servers don't need graphics and omit these packages altogether, relying only on a CLI (Command Line Interface).</p>
<p>Xorg vs Wayland: <a href="https://links.thelinuxbook.com/xvswayland">https://links.thelinuxbook.com/xvswayland</a></p>
<h2 id="display-manager"><a class="header" href="#display-manager">Display Manager</a></h2>
<p>The display manager is essentially the login manager that boots into your desktop environment or window manager.</p>
<h3 id="sddm"><a class="header" href="#sddm">SDDM</a></h3>
<p>This is the display manager for KDE. There are a lot of themes and support for both Wayland and Xorg.</p>
<h3 id="gdm"><a class="header" href="#gdm">GDM</a></h3>
<p>This is the display manager for GNOME. Much like SDDM, lots of themes and support for both Wayland and Xorg.</p>
<h3 id="lightdm"><a class="header" href="#lightdm">LightDM</a></h3>
<p>This is a more universal display manager that multiple desktop environments use because it is lightweight. Xorg Only, but is very lightweight and still widely used.</p>
<p>LightDM Customization: <a href="https://links.thelinuxbook.com/lightdmcustomization">https://links.thelinuxbook.com/lightdmcustomization</a></p>
<h3 id="none"><a class="header" href="#none">None</a></h3>
<p>You technically don't need a display manager, but this means you will boot into a CLI (Command Line Interface) prompt with no graphics. Alternatively, you could set a window manager or desktop environment to auto-launch without requiring a login.</p>
<h2 id="desktop-environments"><a class="header" href="#desktop-environments">Desktop Environments</a></h2>
<p>Desktop environments are the bread and butter of many distributions. These are typically an assortment of programs that dictate how programs are launched, displayed, and configured. Think of these as the look and feel of Linux.</p>
<p>Overview of Desktop Environments: <a href="https://links.thelinuxbook.com/desktopenvironments">https://links.thelinuxbook.com/desktopenvironments</a></p>
<h3 id="kde"><a class="header" href="#kde">KDE</a></h3>
<p>This is a Windows-style desktop environment with a start menu, taskbar, and basic floating window management. The workflow is very similar to Microsoft Windows. It has extensive theming capabilities, desktop widgets, and a vast array of built-in tools.</p>
<p>KDE Customization Video: <a href="https://links.thelinuxbook.com/kdecustomization">https://links.thelinuxbook.com/kdecustomization</a></p>
<h3 id="gnome"><a class="header" href="#gnome">GNOME</a></h3>
<p>GNOME has a unique workflow with window animations and extensions to expand its capabilities. It is unlike any other Desktop Environment out there but has great utility. Its strengths include robust system settings and support for scaling and tablet-style computers.</p>
<h3 id="cinnamon"><a class="header" href="#cinnamon">Cinnamon</a></h3>
<p>This is another Windows-style desktop environment, but it is more simplistic than KDE. The menus are more intuitive, and it has everything the user needs without bundling a ton of applications. This is my first recommendation for Windows users converting to Linux.</p>
<p>Cinnamon Customization Video: <a href="https://links.thelinuxbook.com/cinnamoncustomization">https://links.thelinuxbook.com/cinnamoncustomization</a> (Note: Cinnamon is made by the Linux Mint team.)</p>
<h3 id="mate"><a class="header" href="#mate">MATE</a></h3>
<p>MATE is based on GNOME 2 from the past. It looks a bit dated out of the box, but its minimal design makes it lightweight and functional. It has a traditional menu system, unlike the latest version of GNOME, and can be tweaked to the user's needs without using many resources.</p>
<h3 id="xfce"><a class="header" href="#xfce">XFCE</a></h3>
<p>Minimal, simplistic, and modular—that is XFCE's ethos, and it does a good job of it. It is one of my favorites, even though, like MATE, it is very ugly out of the box. After customization, it can look fantastic.</p>
<p>XFCE Customization Video: <a href="https://links.thelinuxbook.com/xfcecustomization">https://links.thelinuxbook.com/xfcecustomization</a></p>
<h3 id="lxqt--lxde"><a class="header" href="#lxqt--lxde">LXQt / LXDE</a></h3>
<p>LXQt is a very minimal desktop environment with a limited feature set. It is one of the lightest desktop environments on this list and is my recommendation for those using an old PC. Using nearly no resources, it simply gets the job done. LXDE is the older version before it morphed into LXQt.</p>
<h3 id="deepin"><a class="header" href="#deepin">Deepin</a></h3>
<p>This reminds me of macOS and is my recommendation for mac users coming to Linux who don't like GNOME. It is sleek and has a futuristic look out of the box.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>There are many other desktop environments that are less popular than the ones above, and I encourage you to explore them after familiarizing yourself with the ones listed.</p>
<h2 id="window-managers"><a class="header" href="#window-managers">Window Managers</a></h2>
<p>Window managers are often a point of confusion for new users, as people often mix them up with desktop environments. What is the difference? Desktop environments include a suite of tools and utilities, while window managers only manage windows.</p>
<p>I could write another book dedicated specifically to window managers, but I'd only recommend them for advanced users who are capable of making system modifications without the assistance of utilities. For example, adjusting your display settings.</p>
<p>Everything is set up by the user, from adjusting volume to launching programs. Depending on the window manager, you might need to edit text files to configure them or create shortcut keys for programs. Each one is unique and not for the faint of heart. In many of my videos, I use a modified version of DWM, which can be found on my GitHub: <a href="https://github.com/ChrisTitusTech/dwm-titus">https://github.com/ChrisTitusTech/dwm-titus</a></p>
<h2 id="package-manager"><a class="header" href="#package-manager">Package Manager</a></h2>
<p>This is probably the biggest factor that separates distributions and also makes many of them similar. There are a variety of package managers, but I will touch on the most popular ones that most distributions are based on.</p>
<h3 id="apt"><a class="header" href="#apt">APT</a></h3>
<p>Debian-based distributions (e.g., Ubuntu, Pop_OS!, Linux Mint, etc.) use APT, which is one of the oldest package managers on this list. It is also the most widely used. A good majority of Linux articles reference APT. The basic syntax is <code>apt install package</code>.</p>
<h3 id="dnf--yum"><a class="header" href="#dnf--yum">DNF / YUM</a></h3>
<p>RHEL-based distributions (e.g., Fedora, CentOS, Nobara, etc.) use these and dominate the business space. DNF is newer and has better dependency resolution, but you will still see YUM occasionally for legacy systems or older versions. Its basic syntax is <code>dnf install package</code>.</p>
<h3 id="pacman"><a class="header" href="#pacman">Pacman</a></h3>
<p>This is the oddball of the bunch, as it is used in Arch-based distributions (e.g., Manjaro, Garuda, EndeavourOS, etc.). It has non-standard syntax like <code>pacman -S package</code> to install a package.</p>
<h3 id="others-1"><a class="header" href="#others-1">Others</a></h3>
<p>There are many other package managers, but these encompass most of the popular Linux installations.</p>
<h3 id="flatpak--appimage--snapd"><a class="header" href="#flatpak--appimage--snapd">Flatpak / AppImage / SnapD</a></h3>
<p>These are agnostic of any distribution. This means the programs aren't install on the system-level but are self contained. Any dependencies are included with the package which makes them usable on anything Linux. Flatpak and snapd are easy to manage from the command line, but also have lots of files for each package. AppImage is contained within the singular <code>Package.AppImage</code> file. For managing AppImage files, I recommend using <code>gearlever</code> package. For managing permissions on flatpak files, I recommend the <code>flatseal</code> package. I do not recommend using SnapD at all as it is owned and poorly maintained by the company Canonical that distributes Ubuntu.</p>
<h3 id="misconceptions"><a class="header" href="#misconceptions">Misconceptions</a></h3>
<p>It should be noted that most programs can be compiled to work on pretty much any Linux distribution, and all the package manager does is make it easy for you to perform the installation. There are many other ways to install a program, such as building from source. However, most times this isn't needed, as even if a package is not available in your package manager, you can expand it by adding a repository to it, thus giving your package manager access to install even more programs on the fly. Even if this fails or a repository isn't available, you can utilize universal packages like Flatpak, Snap, or AppImage that can install on any system, no matter what package manager you are using.</p>
<h2 id="types-of-linux-installations"><a class="header" href="#types-of-linux-installations">Types of Linux Installations</a></h2>
<p>There are a variety of ways to install Linux, and I will go over them in depth. These methods are broken into three categories: Beginner, Intermediate, and Expert.</p>
<h3 id="beginner-installation"><a class="header" href="#beginner-installation">Beginner Installation</a></h3>
<p>This is extremely easy to do and is where a beginner should start. The downside to a beginner install is that it has less customizability, but it is an easier starting place for a novice user.</p>
<h3 id="intermediate-installation"><a class="header" href="#intermediate-installation">Intermediate Installation</a></h3>
<p>This method typically involves taking a base distribution from the server level and installing the needed packages as required. It yields a highly customized system with a minimal installation but requires the user to know which packages they want.</p>
<h3 id="expert-installation"><a class="header" href="#expert-installation">Expert Installation</a></h3>
<p>Much like intermediate installation, this method advances to not using desktop environments or bundles that install multiple packages. While this method can be tedious, it results in the most minimal installation, as it avoids installing unnecessary packages. However, it requires an extreme skill level to achieve. Often, the user is building packages or even compiling the base Linux kernel.</p>
<h2 id="progression"><a class="header" href="#progression">Progression</a></h2>
<p>The progression you will go through in Linux is much more than these types of installations, but I wanted to give you a path as you explore and move through these types of installations.</p>
<p>Build What You Want Video: <a href="https://links.thelinuxbook.com/buildanything">https://links.thelinuxbook.com/buildanything</a></p>
<footer id="last-change">Last change: 2025-06-17</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="bootloaders-how-linux-is-loaded"><a class="header" href="#bootloaders-how-linux-is-loaded">Bootloaders: How Linux is Loaded</a></h1>
<ul>
<li><a href="chapter3-bootloaders.html#grub-2---the-most-widely-used">GRUB 2 - The Most Widely Used</a>
<ul>
<li><a href="chapter3-bootloaders.html#configuration">Configuration</a>
<ul>
<li><a href="chapter3-bootloaders.html#files-used-for-configuration">Files Used for Configuration</a></li>
<li><a href="chapter3-bootloaders.html#editing-grub-configuration-in-etcdefaultgrub">Editing GRUB Configuration in <code>/etc/default/grub</code></a></li>
<li><a href="chapter3-bootloaders.html#sample-grub-configuration-etcdefaultgrub">Sample GRUB Configuration (<code>/etc/default/grub</code>)</a></li>
<li><a href="chapter3-bootloaders.html#make-configuration-files">Make Configuration files</a></li>
</ul>
</li>
<li><a href="chapter3-bootloaders.html#installation">Installation</a>
<ul>
<li><a href="chapter3-bootloaders.html#efi-installation">EFI Installation</a></li>
<li><a href="chapter3-bootloaders.html#bios-legacy-installation">BIOS Legacy Installation</a></li>
</ul>
</li>
<li><a href="chapter3-bootloaders.html#grub-videos">GRUB Videos</a></li>
</ul>
</li>
<li><a href="chapter3-bootloaders.html#systemd-boot---minimal-built-in-boot">Systemd Boot - Minimal Built-In boot</a>
<ul>
<li><a href="chapter3-bootloaders.html#configuraiton">Configuraiton</a>
<ul>
<li><a href="chapter3-bootloaders.html#general-configuration">General Configuration</a></li>
<li><a href="chapter3-bootloaders.html#adding-boot-entries">Adding Boot Entries</a></li>
</ul>
</li>
<li><a href="chapter3-bootloaders.html#installation-1">Installation</a></li>
</ul>
</li>
</ul>
<p>There are many bootloaders available, but this chapter focuses on the two most widely used: GRUB 2 and systemd-boot.</p>
<h2 id="grub-2---the-most-widely-used"><a class="header" href="#grub-2---the-most-widely-used">GRUB 2 - The Most Widely Used</a></h2>
<p>GRUB 2 is the most popular bootloader for Linux, offering extensive functionality. It supports themes, multiboot setups, and various other features that make it highly versatile. For Windows/Linux multiboot systems, GRUB 2 is my recommended choice.</p>
<ul>
<li><strong>GRUB Manual Table of Contents:</strong> <a href="https://links.thelinuxbook.com/grubtoc">https://links.thelinuxbook.com/grubtoc</a></li>
</ul>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Before installing or updating GRUB, you need to create configuration files. One of the best resources for understanding GRUB is the <a href="https://wiki.gentoo.org/wiki/GRUB2">https://wiki.gentoo.org/wiki/GRUB2</a>.</p>
<h4 id="files-used-for-configuration"><a class="header" href="#files-used-for-configuration">Files Used for Configuration</a></h4>
<div class="table-wrapper"><table><thead><tr><th>File Location</th><th style="text-align: center">Editable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/boot/grub/grub.cfg</code></td><td style="text-align: center">No</td><td>Generated by <code>grub-mkconfig</code> and will be overwritten. Do not edit directly.</td></tr>
<tr><td><code>/etc/grub.d/*</code></td><td style="text-align: center">Yes</td><td>Contains scripts processed in numerical order (e.g., <code>10-boot</code>, <code>11-os</code>).</td></tr>
<tr><td><code>/etc/default/grub</code></td><td style="text-align: center">Yes</td><td>Primary configuration file for GRUB edits. Start here for modifications.</td></tr>
</tbody></table>
</div>
<h4 id="editing-grub-configuration-in-etcdefaultgrub"><a class="header" href="#editing-grub-configuration-in-etcdefaultgrub">Editing GRUB Configuration in <code>/etc/default/grub</code></a></h4>
<p>Below are common configuration entries in <code>/etc/default/grub</code>:</p>
<ul>
<li><strong><code>GRUB_DEFAULT</code></strong>: Specifies the default boot entry. Typically set to <code>0</code> for the first entry. Use <code>1</code> for the second entry, <code>2</code> for the third, and so on.</li>
<li><strong><code>GRUB_TIMEOUT_STYLE</code></strong>: Determines whether to display a menu (<code>MENU</code>) or hide it (<code>HIDDEN</code>). If hidden, the <code>GRUB_HIDDEN_TIMEOUT</code> variable controls the splash screen display.</li>
<li><strong><code>GRUB_TIMEOUT</code></strong>: Sets the menu display duration. If set to <code>-1</code>, the menu will never timeout and will wait for user input.</li>
<li><strong><code>GRUB_CMDLINE_LINUX_DEFAULT</code></strong>: Adds kernel options. Common examples:
<ul>
<li><code>quiet splash</code>: Hides verbose text output during boot.</li>
<li><code>nomodeset</code>: Bypasses modesetting, useful for booting NVIDIA systems to install drivers.</li>
<li><code>single</code>: Boots into single-user mode, useful for system modifications or resetting user passwords.</li>
<li>Variable declarations: Add system-specific variables, such as <code>keymap</code> or <code>vfio</code> for PCI passthrough.</li>
</ul>
</li>
<li><strong><code>GRUB_DISABLE_RECOVERY</code></strong>: Disables recovery entries. Setting this to <code>true</code> is recommended if recovery entries are rarely needed. You can edit GRUB directly during boot by pressing <code>e</code> when the menu appears.</li>
</ul>
<p>For a complete list of GRUB configuration variables, refer to the <a href="https://links.thelinuxbook.com/grubconfig">https://links.thelinuxbook.com/grubconfig</a>.</p>
<h4 id="sample-grub-configuration-etcdefaultgrub"><a class="header" href="#sample-grub-configuration-etcdefaultgrub">Sample GRUB Configuration (<code>/etc/default/grub</code>)</a></h4>
<p>Here’s an example configuration with no menu:</p>
<pre><code>GRUB_DEFAULT="0"
GRUB_TIMEOUT_STYLE="hidden"
GRUB_TIMEOUT="0"
GRUB_DISTRIBUTOR="`lsb_release -i -s 2&gt; /dev/null || echo Debian`"
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""
GRUB_DISABLE_RECOVERY="true"
GRUB_DISABLE_LINUX_RECOVERY="true"
</code></pre>
<h4 id="make-configuration-files"><a class="header" href="#make-configuration-files">Make Configuration files</a></h4>
<p>Make the configuration files with <code>grub-mkconfig</code> or <code>update-grub</code> on debian-based systems.</p>
<pre><code>grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>
<p>Manual page for grub-mkconfig: <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html#Simple-configuration">https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html#Simple-configuration</a></p>
<p>OR</p>
<pre><code>update-grub
</code></pre>
<p>Manual page for update-grub: <a href="https://manpages.debian.org/buster/grub-legacy/update-grub.8.en.html">https://manpages.debian.org/buster/grub-legacy/update-grub.8.en.html</a></p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>Once your configuration files are created, you can install GRUB onto your hard disk for booting. First, determine whether the installation is EFI or Legacy BIOS.</p>
<p>To check if you are using EFI:</p>
<pre><code>ls /sys/firmware/efi
</code></pre>
<p><em>If files are listed with the ls command you are on EFI</em></p>
<h4 id="efi-installation"><a class="header" href="#efi-installation">EFI Installation</a></h4>
<p>Efi installations consist of two partitions where Legacy BIOS can have one. This makes it unique, but can also cause a multiple problems when using manual partitioning. Prior to running these commands you need to make sure the partition is mounted!</p>
<p>Next, we need to install EFI to this partition with this command</p>
<pre><code>grub-install --efi-directory=/boot/efi
</code></pre>
<h4 id="bios-legacy-installation"><a class="header" href="#bios-legacy-installation">BIOS Legacy Installation</a></h4>
<p>Typically in a BIOS legacy setup you have one main partition mounted to / and you run the following command to install GRUB. <strong>Note: DO NOT USE Legacy where you can use EFI!</strong></p>
<pre><code>grub-install 
</code></pre>
<p>You can also do a variation of this if you have multiple drives or are dual booting. Find the drive you are installing it on using the command <code>lsblk</code> OR <code>blkid</code> as these give more information about your drive setup</p>
<p>Example usage when specifying a drive:</p>
<pre><code>grub-install /dev/sda
</code></pre>
<p>For the full usage of grub-install here is the manual page: <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html">https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html</a></p>
<h3 id="grub-videos"><a class="header" href="#grub-videos">GRUB Videos</a></h3>
<p>These are the videos I've done on GRUB via YouTube:</p>
<ul>
<li>How to Repair Linux With Boot Failure: <a href="https://links.thelinuxbook.com/repairgrubbootfail">https://links.thelinuxbook.com/repairgrubbootfail</a></li>
<li>Fix Multi-Boot Systems running GRUB and Windows: <a href="https://links.thelinuxbook.com/fixmultiboot">https://links.thelinuxbook.com/fixmultiboot</a></li>
<li>Using SuperGRUBDisk to repair GRUB: <a href="https://links.thelinuxbook.com/supergrub">https://links.thelinuxbook.com/supergrub</a></li>
<li>Custom Bootloader Themes Project: <a href="https://links.thelinuxbook.com/bootloaderthemes">https://links.thelinuxbook.com/bootloaderthemes</a></li>
<li>Using GRUB Rescue: <a href="https://links.thelinuxbook.com/grubrescue">https://links.thelinuxbook.com/grubrescue</a></li>
</ul>
<h2 id="systemd-boot---minimal-built-in-boot"><a class="header" href="#systemd-boot---minimal-built-in-boot">Systemd Boot - Minimal Built-In boot</a></h2>
<p>Many distributions are now starting to ship with systemd boot instead of GRUB (PopOS! is one example) and is an interesting boot manager when you don't want a menu or extra packages to boot into your Linux.</p>
<p><em>Note: systemd boot has the capabilities of menus and dual boot, but setting this up is much more cumbersome and why I recommend using GRUB instead of doing this</em></p>
<p>Systemd-boot is also an <em>EFI ONLY</em> bootloader. So if you aren't booted in using UEFI, you can NOT install systemd-boot. Verify that you are in efi mode using <code>ls /sys/firmware/efi</code></p>
<p>Systemd has a dedicated site for documentation. Check it out @ <a href="https://systemd.io/">https://systemd.io/</a> and look at the Booting Section for systemd-boot. Another good source for systemd-boot information is the Arch Wiki @ <a href="https://wiki.archlinux.org/title/systemd-boot">https://wiki.archlinux.org/title/systemd-boot</a></p>
<h3 id="configuraiton"><a class="header" href="#configuraiton">Configuraiton</a></h3>
<p>Here is the directory breakdown for systemd-boot</p>
<ul>
<li>Main Directory: /boot/efi (Sometimes this can be /boot in rare instances and some systems it adds a EFI subdirectory, ex. /boot/efi/EFI)</li>
<li>Configuration files: /boot/efi/loader (General configuration in loader.conf)</li>
<li>OS Entries: /boot/efi/loader/entries (Each .conf is a boot entry)</li>
</ul>
<h4 id="general-configuration"><a class="header" href="#general-configuration">General Configuration</a></h4>
<p>The general configuration will be the loader.conf in the root of the <code>/loader</code> directory. Here is the syntax:</p>
<ul>
<li>default – Default boot option and it can be a wildcard like arch-*.conf.</li>
<li>timeout – menu timeout in seconds before the default entry is booted. If this is not set, the menu will only be shown on key press during boot.</li>
<li>editor – yes is default, but this allows editing boot entries and can be used to reset password or get system level access. Set to no if security is a concern.</li>
<li>auto-entries – shows automatic entries for Windows, EFI Shell, and Default Loader if set to 1 (default), 0 to hide;</li>
<li>auto-firmware – shows entry for rebooting into UEFI firmware settings if set to 1 (default), 0 to hide;</li>
<li>console-mode – changes UEFI console mode:
<ul>
<li>0 for 80x25</li>
<li>1 for 80x50</li>
<li>2 and above for non-standard modes provided by the device firmware</li>
<li>auto picks a suitable mode automatically</li>
<li>max for highest available mode</li>
<li>keep (default) for the firmware selected mode.</li>
</ul>
</li>
</ul>
<p><em>boot/efi/loader/loader.conf</em> example</p>
<pre><code>default  arch.conf
timeout  4
console-mode max
editor   no
</code></pre>
<h4 id="adding-boot-entries"><a class="header" href="#adding-boot-entries">Adding Boot Entries</a></h4>
<p>Every boot entry will be loaded from the <code>/loader/entries</code> directory. Here is that syntax:</p>
<ul>
<li>
<p>title – operating system name. Required.</p>
</li>
<li>
<p>version – kernel version. Optional.</p>
</li>
<li>
<p>machine-id – machine identifier from /etc/machine-id. Optional.</p>
</li>
<li>
<p>efi – EFI program to start. Either this parameter or linux is <em>required</em>.</p>
</li>
<li>
<p>options – space-separated command line options to pass to the EFI program or kernel parameters. <code>root="UUID=3255683f-53a2-4fdf-91cf" OR root="LABEL=OS Label"</code> is required for booting Linux. Here are common options:</p>
<ul>
<li>rw = Read-Write needed for most installs</li>
<li>root = UUID or Label used for identifying the root partition</li>
<li>silent = do NOT display any console output</li>
<li>splash = display OS Splash screen</li>
<li>nomodeset = disable Kernel mode setting. Often needed if using NVIDIA cards and you do not have the drivers installed.</li>
<li>S = run in single mode (often required for resetting root password or modifying root file system)</li>
</ul>
<p>Q: How do you find the UUID?
A: The command <code>sudo blkid</code></p>
<p>_Note: To identify specific drive labels I recommend <code>sudo lsblk</code> which gives a readout of all drives and where they are mounted. When used in conjunction with <code>blkid</code> you will be able to tell what each drive is.</p>
</li>
</ul>
<p>Check all kernel parameters @ <a href="https://links.thelinuxbook.com/kernelparameters">https://links.thelinuxbook.com/kernelparameters</a></p>
<p>Example Arch Linux Entry <code>/boot/efi/loader/entries/arch.conf</code></p>
<pre><code>title   Arch Linux
linux   /vmlinuz-linux
initrd  /intel-ucode.img
initrd  /initramfs-linux.img
options root="LABEL=arch" rw
</code></pre>
<p>Example Windows 10 Entry <code>/boot/efi/loader/entries/win10.conf</code></p>
<pre><code>title Windows 10
efi /EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>Automatic EFI Entry creation with the <code>efibootmgr</code> package - You can check to see what efi options are installed to you with <code>efibootmgr -v</code>.</p>
<pre><code>efibootmgr --create --disk /dev/sda --part 1 --loader "\EFI\systemd\systemd-bootx64.efi" --label "Linux OS" --verbose
</code></pre>
<p><em>Note: This command is used if your Linux EFI system partition is located @ /dev/sda1 and the EFI file located @ /boot/efi/EFI/systemd/systemd-bootx64.efi</em></p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>The default install is very easy once configuration is done. You simply type <code>bootctl install</code> and you are done!</p>
<p>There are configurations with multiple boot partitions, but I do not recommend using systemd-boot for this.</p>
<p>In most instances this will auto update when boot options change, but you can force an update if you manually add more entries with <code>bootctl update</code></p>
<footer id="last-change">Last change: 2025-06-17</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="server-command-line-interface-mastering-the-terminal"><a class="header" href="#server-command-line-interface-mastering-the-terminal">Server Command Line Interface: Mastering the Terminal</a></h1>
<ul>
<li><a href="chapter4-servercli.html#navigating-the-command-line-interface">Navigating the Command Line Interface</a>
<ul>
<li><a href="chapter4-servercli.html#types-of-terminals">Types of Terminals</a>
<ul>
<li><a href="chapter4-servercli.html#recommended-gui-terminals">Recommended GUI Terminals:</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#directory-movement-commands-and-examples">Directory Movement Commands and Examples:</a></li>
<li><a href="chapter4-servercli.html#directory-layout-and-file-system-overview">Directory Layout and File System Overview</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#system-services-and-configuration">System Services and Configuration</a>
<ul>
<li><a href="chapter4-servercli.html#controlling-services-and-units">Controlling Services and Units</a>
<ul>
<li><a href="chapter4-servercli.html#common-systemctl-commands">Common <code>systemctl</code> Commands:</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#unit-file-locations">Unit File Locations</a></li>
<li><a href="chapter4-servercli.html#example-system-unit-file">Example System Unit File</a></li>
<li><a href="chapter4-servercli.html#user-based-systemd-services-and-unit-files">User-Based Systemd Services and Unit Files</a>
<ul>
<li><a href="chapter4-servercli.html#example-command">Example Command:</a></li>
<li><a href="chapter4-servercli.html#example-user-unit-file">Example User Unit File:</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#bluetooth-configuration">Bluetooth Configuration</a>
<ul>
<li><a href="chapter4-servercli.html#common-bluetoothctl-commands">Common <code>bluetoothctl</code> Commands:</a></li>
<li><a href="chapter4-servercli.html#example-usage">Example Usage:</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#audio-configuration">Audio Configuration</a>
<ul>
<li><a href="chapter4-servercli.html#pulseaudio-commands-pactl">PulseAudio Commands (<code>pactl</code>)</a></li>
<li><a href="chapter4-servercli.html#alsa-mixer-alsamixer">ALSA Mixer (<code>alsamixer</code>)</a></li>
<li><a href="chapter4-servercli.html#common-audio-troubleshooting-commands">Common Audio Troubleshooting Commands</a></li>
<li><a href="chapter4-servercli.html#audio-device-management-with-pavucontrol">Audio Device Management with <code>pavucontrol</code></a></li>
<li><a href="chapter4-servercli.html#pipewire-audio-system">Pipewire Audio System</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#remote-access-and-ssh">Remote Access and SSH</a>
<ul>
<li><a href="chapter4-servercli.html#setting-up-ssh">Setting Up SSH</a></li>
<li><a href="chapter4-servercli.html#connecting-to-a-remote-server">Connecting to a Remote Server</a></li>
<li><a href="chapter4-servercli.html#common-ssh-options">Common SSH Options</a></li>
<li><a href="chapter4-servercli.html#ssh-configuration-file">SSH Configuration File</a></li>
<li><a href="chapter4-servercli.html#remote-file-transfer-with-scp-and-sftp">Remote File Transfer with SCP and SFTP</a></li>
<li><a href="chapter4-servercli.html#remote-desktop-access">Remote Desktop Access</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#lamp-stack-linux-apache-mysql-php-website-setup">LAMP Stack (Linux, Apache, MySQL, PHP) Website Setup</a>
<ul>
<li><a href="chapter4-servercli.html#installing-the-lamp-stack">Installing the LAMP Stack</a></li>
<li><a href="chapter4-servercli.html#testing-the-lamp-stack">Testing the LAMP Stack</a></li>
</ul>
</li>
<li><a href="chapter4-servercli.html#finding-ip-address-and-hostname">Finding IP Address and Hostname</a></li>
<li><a href="chapter4-servercli.html#find-hostname">Find hostname</a></li>
</ul>
</li>
</ul>
<p>This chapter covers the most important aspect of Linux: <strong>the terminal</strong>. The terminal is the beating heart of Linux, enabling you to accomplish virtually anything. For the first eight years I used Linux, I relied exclusively on the terminal, never even considering a graphical interface. The terminal is reliable, quick, and efficient, making it an indispensable tool for Linux users.</p>
<p><strong>Pro Tip:</strong> The terminal is always accessible. If you're stuck on a black screen or graphical interface, press <code>Ctrl + Alt + F2</code> or <code>Ctrl + Alt + F3</code> to switch to a terminal. To return to the graphical interface, press <code>Ctrl + Alt + F7</code>.</p>
<hr />
<h2 id="navigating-the-command-line-interface"><a class="header" href="#navigating-the-command-line-interface">Navigating the Command Line Interface</a></h2>
<p>Videos: How to Make Bash Terminal look and feel GREAT! <a href="https://links.thelinuxbook.com/prettybash">https://links.thelinuxbook.com/prettybash</a></p>
<h3 id="types-of-terminals"><a class="header" href="#types-of-terminals">Types of Terminals</a></h3>
<ul>
<li><strong>TTY</strong>: A terminal connected to a physical device, such as a keyboard and monitor</li>
<li><strong>GUI Terminal</strong>: A terminal emulator that provides a graphical interface for command-line operations, such as GNOME Terminal, Konsole, or xterm</li>
</ul>
<p>TTY is used for direct interaction with the system, while GUI terminals provide a more user-friendly experience with features like tabs, copy-paste, and customizable appearance. TTY is often used for system recovery or when the graphical interface is unavailable or malfunctioning.</p>
<p>To access a TTY terminal, you can use the following key combinations:</p>
<ul>
<li><code>Ctrl + Alt + F1</code> to <code>Ctrl + Alt + F6</code>: Switch to different TTY terminals (TTY1 to TTY6)</li>
<li><code>Ctrl + Alt + F7</code>: Return to the graphical interface (usually TTY7)</li>
</ul>
<p>GUI Terminals are typically launched from the applications menu or by pressing <code>Ctrl + Alt + T</code> in most desktop environments or hotkey like <code>Super + Enter</code> in many Tiled Window Managers (TWM).</p>
<h4 id="recommended-gui-terminals"><a class="header" href="#recommended-gui-terminals">Recommended GUI Terminals:</a></h4>
<ul>
<li><strong>GNOME Terminal</strong>: Default terminal for GNOME desktop environments, supports tabs and profiles</li>
<li><strong>Konsole</strong>: Default terminal for KDE Plasma, highly customizable with split views and profiles</li>
<li><strong>Alacritty</strong>: A fast, GPU-accelerated terminal emulator with a focus on performance and simplicity</li>
<li><strong>Kitty</strong>: A feature-rich terminal emulator with support for graphics</li>
<li><strong>Terminator</strong>: Allows multiple terminal windows in a single window, with customizable layouts</li>
</ul>
<h3 id="directory-movement-commands-and-examples"><a class="header" href="#directory-movement-commands-and-examples">Directory Movement Commands and Examples:</a></h3>
<ul>
<li><code>cd</code> (change directory):
<ul>
<li><code>cd ..</code> (move up a directory)</li>
<li><code>cd name</code> (move into the specified directory)</li>
<li><code>cd /</code> (move to the root directory)</li>
<li><code>cd ~</code> (move to the home directory, e.g., <code>/home/titus</code>)</li>
<li><code>zoxide</code> - A better package for navigating the file system, using fuzzy finding and remembering past directories.
_Note: <code>zoxide</code> is a third-party tool that can be installed via your package manager. Watch the video I did on Zoxide: <a href="https://links.thelinuxbook.com/zoxide">https://links.thelinuxbook.com/zoxide</a></li>
</ul>
</li>
<li><code>ls</code> (list files):
<ul>
<li><code>ls -a</code> (show all files, including hidden ones)</li>
<li><code>ls -l</code> (long listing format showing permissions)</li>
</ul>
</li>
<li><code>rm</code> (remove files):
<ul>
<li><code>rm -rf</code> (remove files/directories recursively and forcefully)</li>
<li><code>rmdir</code> (remove empty directories)</li>
<li><code>trash-cli</code> - An alternative to <code>rm</code> that moves files to the trash instead of permanently deleting them.</li>
</ul>
</li>
<li><code>cp</code> (copy files):
<ul>
<li><code>cp -r</code> (copy files and subdirectories recursively)</li>
<li><code>rsync</code> - A more efficient tool for copying or syncing large amounts of files.</li>
</ul>
</li>
<li><code>mv</code> (move files):
<ul>
<li><code>mv file1.txt file2.txt</code> (rename or move files)</li>
<li><code>mv /path/to/file /new/path/</code> (move a file to a new location)</li>
</ul>
</li>
<li><code>pwd</code> (print working directory):
<ul>
<li>Displays the current directory path.</li>
</ul>
</li>
<li><code>find</code> (search for files):
<ul>
<li><code>find /path/to/search -name "filename"</code> (search for a file by name)</li>
<li><code>find /path/to/search -type d -name "dirname"</code> (search for a directory by name)</li>
<li><code>fd</code> - A faster alternative to <code>find</code> with a simpler syntax.</li>
</ul>
</li>
<li><code>locate</code> (find files by name):
<ul>
<li><code>locate filename</code> (find files by name using a pre-built index)</li>
<li><code>updatedb</code> (update the locate database, usually run automatically by the system)</li>
</ul>
</li>
<li><code>tree</code> (display directory structure):
<ul>
<li><code>tree</code> (display the directory structure in a tree-like format)</li>
<li><code>tree -L 2</code> (limit the depth of the tree display to 2 levels)</li>
</ul>
</li>
<li><code>ln</code> (create links):
<ul>
<li><code>ln -s /path/to/original /path/to/link</code> (create a symbolic link)</li>
<li><code>ln /path/to/original /path/to/link</code> (create a hard link)</li>
</ul>
</li>
<li><code>chmod</code> (change file permissions):
<ul>
<li><code>chmod 755 file</code> (set permissions to read, write, and execute for owner, and read and execute for group and others)</li>
<li><code>chmod +x script.sh</code> (make a script executable)</li>
</ul>
</li>
<li><code>chown</code> (change file ownership):
<ul>
<li><code>chown user:group file</code> (change ownership of a file to a specific user and group)</li>
<li><code>chown -R user:group /path/to/directory</code> (change ownership recursively for a directory)</li>
</ul>
</li>
<li><code>stat</code> (display file or filesystem status):
<ul>
<li><code>stat file</code> (show detailed information about a file, including size, permissions, and timestamps)</li>
<li><code>stat /path/to/directory</code> (show information about a directory)</li>
</ul>
</li>
<li><code>du</code> (disk usage):
<ul>
<li><code>du -h</code> (display disk usage in human-readable format)</li>
<li><code>du -sh /path/to/directory</code> (show total size of a directory)</li>
</ul>
</li>
<li><code>df</code> (disk space usage):
<ul>
<li><code>df -h</code> (display disk space usage in human-readable format)</li>
<li><code>df -i</code> (show inode usage instead of disk space)</li>
</ul>
</li>
</ul>
<hr />
<h3 id="directory-layout-and-file-system-overview"><a class="header" href="#directory-layout-and-file-system-overview">Directory Layout and File System Overview</a></h3>
<ul>
<li><code>/</code> - Root directory</li>
<li><code>/bin</code> - System executable files</li>
<li><code>/boot</code> - Bootloader files</li>
<li><code>/dev</code> - Device files (requires mounting to browse)</li>
<li><code>/etc</code> - System configuration files</li>
<li><code>/home</code> - User files and configuration files</li>
<li><code>/media</code> - Mounted external media</li>
<li><code>/mnt</code> - Temporary mount points</li>
<li><code>/opt</code> - Optional files</li>
<li><code>/root</code> - Root user files and configurations</li>
<li><code>/tmp</code> - Temporary files</li>
<li><code>/usr</code> - System resources</li>
<li><code>/var</code> - Logs, databases, and other variable data</li>
</ul>
<p>Most interactions with the file system occur within the <code>/home/user</code> directory. This includes configuration files and executable programs. Direct editing of system-wide configuration files in <code>/etc</code> or adding programs to <code>/bin</code> should be done sparingly.</p>
<hr />
<h2 id="system-services-and-configuration"><a class="header" href="#system-services-and-configuration">System Services and Configuration</a></h2>
<p>Modern Linux distributions use an "init system" to control system operations, primarily <strong>systemd</strong>. Systemd manages services, boot processes, networking, and more.</p>
<hr />
<h3 id="controlling-services-and-units"><a class="header" href="#controlling-services-and-units">Controlling Services and Units</a></h3>
<p><code>systemctl</code> is the primary tool for managing services and units in systemd. Units can represent services, device drivers, network mounts, timers (similar to <code>crontab</code>), and more.</p>
<h4 id="common-systemctl-commands"><a class="header" href="#common-systemctl-commands">Common <code>systemctl</code> Commands:</a></h4>
<ul>
<li><code>systemctl status servicename</code> - View the current status of a service.</li>
<li><code>systemctl start servicename</code> - Start a service.</li>
<li><code>systemctl stop servicename</code> - Stop a service.</li>
<li><code>systemctl restart servicename</code> - Restart a service (stop and start).</li>
<li><code>systemctl reload servicename</code> - Reload the configuration file without restarting the service.</li>
<li><code>systemctl enable servicename</code> - Enable a service to start at system boot.</li>
<li><code>systemctl is-enabled servicename</code> - Check if a service is enabled at startup.</li>
<li><code>systemctl is-active servicename</code> - Check if a service is running and active.</li>
<li><code>systemctl list-units</code> - List all running systemd units.</li>
<li><code>systemctl list-units --all</code> - List all units, both active and inactive.</li>
<li><code>systemctl list-units --all --state=inactive</code> - List all inactive units.</li>
<li><code>systemctl list-units --all --type=service</code> - List all units of type "service."</li>
</ul>
<hr />
<h3 id="unit-file-locations"><a class="header" href="#unit-file-locations">Unit File Locations</a></h3>
<p>Systemd unit files are typically located in the following directories:</p>
<ul>
<li><code>/usr/lib/systemd</code> - The main location for system-created unit files.</li>
<li><code>/etc/systemd/system</code> - Contains system-wide unit files, often symbolic links to <code>/usr/lib/systemd</code>. This directory has <strong>top priority</strong> when reading unit files.</li>
<li><code>~/.config/systemd/user/</code> - Contains user-specific unit files. This directory is not created by default and requires the <code>--user</code> option for systemctl commands.</li>
</ul>
<hr />
<h3 id="example-system-unit-file"><a class="header" href="#example-system-unit-file">Example System Unit File</a></h3>
<p>Below is an example of a system unit file:</p>
<pre><code>[Unit]
Description=service_description
After=network.target

[Service]
ExecStart=path_to_executable
Type=forking

[Install]
WantedBy=default.target
</code></pre>
<p>For a full reference, Systemd Unit Documentation <a href="https://links.thelinuxbook.com/systemd">https://links.thelinuxbook.com/systemd</a>.</p>
<hr />
<h3 id="user-based-systemd-services-and-unit-files"><a class="header" href="#user-based-systemd-services-and-unit-files">User-Based Systemd Services and Unit Files</a></h3>
<p>User-specific unit files are stored in the <code>~/.config/systemd/user/</code> directory. These files can be managed using the <code>--user</code> option with <code>systemctl</code>.</p>
<h4 id="example-command"><a class="header" href="#example-command">Example Command:</a></h4>
<pre><code class="language-bash">systemctl --user start usercreatedfile.service
</code></pre>
<p>This command starts a user-created service file located in the user's home directory.</p>
<h4 id="example-user-unit-file"><a class="header" href="#example-user-unit-file">Example User Unit File:</a></h4>
<pre><code>[Unit]
Description=Run service as user
DefaultDependencies=no
After=network.target

[Service]
Type=simple
User=titus
Group=users
ExecStart=/home/titus/scripts/startup_script.sh
TimeoutStartSec=0
RemainAfterExit=yes

[Install]
WantedBy=default.target
</code></pre>
<h3 id="bluetooth-configuration"><a class="header" href="#bluetooth-configuration">Bluetooth Configuration</a></h3>
<p>To configure Bluetooth, you can use the <code>bluetoothctl</code> command-line tool. This tool allows you to manage Bluetooth devices and settings directly from the terminal.</p>
<p>Syntax for <code>bluetoothctl</code> commands:</p>
<pre><code class="language-bash">bluetoothctl [command]
</code></pre>
<h4 id="common-bluetoothctl-commands"><a class="header" href="#common-bluetoothctl-commands">Common <code>bluetoothctl</code> Commands:</a></h4>
<ul>
<li><code>power on</code> - Turn on the Bluetooth adapter.</li>
<li><code>power off</code> - Turn off the Bluetooth adapter.</li>
<li><code>agent on</code> - Enable the agent for pairing.</li>
<li><code>scan on</code> - Start scanning for nearby Bluetooth devices.</li>
<li><code>scan off</code> - Stop scanning for Bluetooth devices.</li>
<li><code>pair &lt;device_address&gt;</code> - Pair with a specific Bluetooth device.</li>
<li><code>connect &lt;device_address&gt;</code> - Connect to a paired Bluetooth device.</li>
<li><code>disconnect &lt;device_address&gt;</code> - Disconnect from a connected Bluetooth device.</li>
<li><code>devices</code> - List all known Bluetooth devices.</li>
<li><code>info &lt;device_address&gt;</code> - Show detailed information about a specific Bluetooth device.</li>
</ul>
<h4 id="example-usage"><a class="header" href="#example-usage">Example Usage:</a></h4>
<pre><code class="language-bash">bluetoothctl
power on
agent on
scan on
</code></pre>
<p>This will turn on the Bluetooth adapter, enable the agent for pairing, and start scanning for nearby Bluetooth devices.</p>
<p><em>Note: <code>blueman</code> is a graphical Bluetooth manager that can be used as an alternative to <code>bluetoothctl</code> for those who prefer a GUI.</em></p>
<h3 id="audio-configuration"><a class="header" href="#audio-configuration">Audio Configuration</a></h3>
<p>Linux provides several command-line tools for managing audio. The two main sound systems are ALSA (Advanced Linux Sound Architecture) and PulseAudio, with PulseAudio running on top of ALSA.</p>
<h4 id="pulseaudio-commands-pactl"><a class="header" href="#pulseaudio-commands-pactl">PulseAudio Commands (<code>pactl</code>)</a></h4>
<p>The <code>pactl</code> command is used to control the PulseAudio sound server:</p>
<pre><code class="language-bash"># List audio sources and sinks
pactl list sources        # List input devices
pactl list sinks         # List output devices

# Volume control
pactl set-sink-volume @DEFAULT_SINK@ 50%     # Set volume to 50%
pactl set-sink-mute @DEFAULT_SINK@ toggle    # Toggle mute

# List loaded modules
pactl list modules
</code></pre>
<h4 id="alsa-mixer-alsamixer"><a class="header" href="#alsa-mixer-alsamixer">ALSA Mixer (<code>alsamixer</code>)</a></h4>
<p><code>alsamixer</code> is a terminal-based mixer program for ALSA:</p>
<pre><code class="language-bash">alsamixer    # Open the mixer interface
</code></pre>
<p>Navigation in <code>alsamixer</code>:</p>
<ul>
<li>Arrow keys: Navigate between channels</li>
<li>Up/Down: Adjust volume</li>
<li>M: Toggle mute</li>
<li>F6: Select sound card</li>
<li>Esc: Exit</li>
</ul>
<h4 id="common-audio-troubleshooting-commands"><a class="header" href="#common-audio-troubleshooting-commands">Common Audio Troubleshooting Commands</a></h4>
<pre><code class="language-bash"># Restart PulseAudio
pulseaudio -k        # Kill the PulseAudio daemon
pulseaudio --start   # Start PulseAudio

# Check audio devices
aplay -l             # List all ALSA playback devices
arecord -l          # List all ALSA recording devices

# Test audio output
speaker-test -c 2    # Test stereo speakers
</code></pre>
<h4 id="audio-device-management-with-pavucontrol"><a class="header" href="#audio-device-management-with-pavucontrol">Audio Device Management with <code>pavucontrol</code></a></h4>
<p>While <code>pavucontrol</code> is technically a GUI application, it can be installed and launched from the terminal:</p>
<pre><code class="language-bash">sudo apt install pavucontrol   # Install on Debian/Ubuntu
pavucontrol                    # Launch the control interface
</code></pre>
<h4 id="pipewire-audio-system"><a class="header" href="#pipewire-audio-system">Pipewire Audio System</a></h4>
<p>Pipewire is the modern replacement for both PulseAudio and JACK. It maintains compatibility with PulseAudio clients, so <code>pactl</code> commands work with Pipewire. Additionally, Pipewire provides its own tools:</p>
<pre><code class="language-bash"># Check Pipewire status
pw-cli status
pw-top                # Show real-time audio processing graph

# List audio devices
pw-dump               # Detailed info about audio devices and nodes
pw-cli list-objects   # List all Pipewire objects

# Control specific nodes
pw-cli node-id        # Get ID of audio nodes
pw-metadata -n settings 0 clock.force-rate 48000  # Set sample rate

# Monitor audio
pw-mon               # Monitor Pipewire events in real-time
</code></pre>
<p>You can still use PulseAudio tools with Pipewire:</p>
<ul>
<li><code>pactl</code> commands work as shown above</li>
<li><code>pavucontrol</code> works normally</li>
<li>ALSA applications work without modification</li>
</ul>
<p><em>Note: Most modern Linux distributions are transitioning to Pipewire as their default audio system due to its improved latency, Bluetooth handling, and compatibility with both PulseAudio and JACK applications.</em></p>
<h5 id="typical-pipewire-package-names"><a class="header" href="#typical-pipewire-package-names">Typical Pipewire Package Names:</a></h5>
<ul>
<li><code>pipewire</code> - Core Pipewire package</li>
<li><code>pipewire-pulse</code> - PulseAudio compatibility layer</li>
<li><code>pipewire-jack</code> - JACK compatibility layer</li>
<li><code>pipewire-alsa</code> - ALSA compatibility layer</li>
<li><code>wireplumber</code> - Session manager for Pipewire</li>
</ul>
<p><em>Note: Do NOT use pipewire-media-session, as it is deprecated and replaced by wireplumber.</em></p>
<h3 id="remote-access-and-ssh"><a class="header" href="#remote-access-and-ssh">Remote Access and SSH</a></h3>
<p>Remote access is a crucial aspect of server management. The most common method for remote access in Linux is through SSH (Secure Shell). SSH allows you to securely connect to a remote machine and execute commands as if you were physically present.</p>
<h4 id="setting-up-ssh"><a class="header" href="#setting-up-ssh">Setting Up SSH</a></h4>
<p>To set up SSH on your Linux server, follow these steps:</p>
<ol>
<li>
<p><strong>Install OpenSSH Server</strong>:</p>
<pre><code class="language-bash">sudo apt install openssh-server  # Debian/Ubuntu
sudo dnf install openssh-server  # Fedora/RHEL
sudo pacman -S openssh            # Arch Linux
</code></pre>
</li>
<li>
<p><strong>Start and Enable the SSH Service</strong>:</p>
<pre><code class="language-bash">sudo systemctl start sshd         # Start the SSH service
sudo systemctl enable sshd        # Enable SSH to start on boot
</code></pre>
</li>
<li>
<p><strong>Check SSH Status</strong>:</p>
<pre><code class="language-bash">sudo systemctl status sshd        # Check the status of the SSH service
</code></pre>
</li>
<li>
<p><strong>Configure SSH</strong>:
Edit the SSH configuration file located at <code>/etc/ssh/sshd_config</code> to customize settings such as port number, allowed users, and authentication methods.</p>
<pre><code class="language-bash">sudo nano /etc/ssh/sshd_config
</code></pre>
<p>Common configurations include:</p>
<ul>
<li><code>Port 22</code> (change to a different port for security)</li>
<li><code>PermitRootLogin no</code> (disable root login for security)</li>
<li><code>PasswordAuthentication yes/no</code> (enable or disable password authentication)</li>
</ul>
</li>
<li>
<p><strong>Restart SSH Service</strong>:</p>
<pre><code class="language-bash">sudo systemctl restart sshd       # Restart the SSH service to apply changes
</code></pre>
<p>For more advanced SSH configurations, you can set up key-based authentication, which is more secure than password-based authentication. To do this, generate an SSH key pair on your local machine and copy the public key to the server:</p>
</li>
</ol>
<pre><code class="language-bash">ssh-keygen
</code></pre>
<p>This command generates a public/private key pair. You can then copy the public key to the server using:
<em>Note: id_rsa.pub is the default public key file generated by ssh-keygen with default options.</em></p>
<pre><code class="language-bash">ssh-copy-id user@server_ip -i ~/.ssh/id_rsa.pub
</code></pre>
<p>This command copies your public key to the server's <code>~/.ssh/authorized_keys</code> file, allowing you to log in without a password.</p>
<h4 id="connecting-to-a-remote-server"><a class="header" href="#connecting-to-a-remote-server">Connecting to a Remote Server</a></h4>
<p>To connect to a remote server using SSH, use the following command:</p>
<pre><code class="language-bash">ssh user@server_ip
</code></pre>
<p>Replace <code>user</code> with your username on the remote server and <code>server_ip</code> with the server's IP address or hostname. If you changed the SSH port, use the <code>-p</code> option:</p>
<pre><code class="language-bash">ssh -p port_number user@server_ip
</code></pre>
<h4 id="common-ssh-options"><a class="header" href="#common-ssh-options">Common SSH Options</a></h4>
<ul>
<li><code>-i /path/to/private_key</code>: Specify a private key file for authentication.</li>
<li><code>-X</code>: Enable X11 forwarding to run graphical applications over SSH.</li>
<li><code>-C</code>: Enable compression for faster transfers.</li>
<li><code>-v</code>: Enable verbose mode for debugging connection issues.</li>
</ul>
<h4 id="ssh-configuration-file"><a class="header" href="#ssh-configuration-file">SSH Configuration File</a></h4>
<p>You can create a configuration file at <code>~/.ssh/config</code> to simplify SSH connections. Here’s an example configuration:</p>
<pre><code>Host myserver
    HostName server_ip
    User user
    Port 22
    IdentityFile ~/.ssh/id_rsa
</code></pre>
<p>This allows you to connect to the server using:</p>
<pre><code class="language-bash">ssh myserver
</code></pre>
<h4 id="remote-file-transfer-with-scp-and-sftp"><a class="header" href="#remote-file-transfer-with-scp-and-sftp">Remote File Transfer with SCP and SFTP</a></h4>
<p>To transfer files between your local machine and a remote server, you can use <code>scp</code> (Secure Copy Protocol) or <code>sftp</code> (SSH File Transfer Protocol).</p>
<h5 id="using-scp"><a class="header" href="#using-scp">Using SCP</a></h5>
<p>To copy a file from your local machine to a remote server:</p>
<pre><code class="language-bash">scp /path/to/local/file user@server_ip:/path/to/remote/directory
</code></pre>
<p>To copy a file from a remote server to your local machine:</p>
<pre><code class="language-bash">scp user@server_ip:/path/to/remote/file /path/to/local/directory
</code></pre>
<h5 id="using-sftp"><a class="header" href="#using-sftp">Using SFTP</a></h5>
<p>To start an SFTP session with a remote server:</p>
<pre><code class="language-bash">sftp user@server_ip
</code></pre>
<p>Once connected, you can use commands like <code>get</code>, <code>put</code>, <code>ls</code>, and <code>cd</code> to navigate and transfer files:</p>
<pre><code class="language-bash">get remote_file.txt          # Download a file from the server
put local_file.txt           # Upload a file to the server
ls                            # List files in the current directory
cd /path/to/directory        # Change directory on the server
</code></pre>
<h4 id="remote-desktop-access"><a class="header" href="#remote-desktop-access">Remote Desktop Access</a></h4>
<p>For graphical remote access, you can use tools like VNC (Virtual Network Computing) or RDP (Remote Desktop Protocol). These tools allow you to access the graphical desktop environment of a remote server.</p>
<p>VNC allows you to remotely control a graphical desktop environment. To set up a VNC server, you can use TigerVNC or x11vnc.</p>
<h5 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h5>
<pre><code class="language-bash">sudo apt update
sudo apt install tigervnc-standalone-server tigervnc-common
</code></pre>
<h5 id="fedora"><a class="header" href="#fedora">Fedora</a></h5>
<pre><code class="language-bash">sudo dnf install tigervnc-server tigervnc-server-module
</code></pre>
<h5 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h5>
<pre><code class="language-bash">sudo pacman -S tigervnc
</code></pre>
<h5 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h5>
<h6 id="1-set-vnc-password"><a class="header" href="#1-set-vnc-password">1. Set VNC Password</a></h6>
<pre><code class="language-bash">vncpasswd
</code></pre>
<h6 id="2-create-vnc-service-configuration"><a class="header" href="#2-create-vnc-service-configuration">2. Create VNC Service Configuration</a></h6>
<h6 id="for-debianubuntu-and-arch"><a class="header" href="#for-debianubuntu-and-arch">For Debian/Ubuntu and Arch:</a></h6>
<p>Create a systemd service file:</p>
<pre><code class="language-bash">sudo nano /etc/systemd/system/vncserver@.service
</code></pre>
<p>Add the following content:</p>
<pre><code class="language-ini">[Unit]
Description=Start TigerVNC server at startup
After=syslog.target network.target

[Service]
Type=forking
User=your-username
Group=your-username
WorkingDirectory=/home/your-username

PIDFile=/home/your-username/.vnc/%H:%i.pid
ExecStartPre=-/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1
ExecStart=/usr/bin/vncserver -depth 24 -geometry 1024x768 -localhost :%i
ExecStop=/usr/bin/vncserver -kill :%i

[Install]
WantedBy=multi-user.target
</code></pre>
<h6 id="for-fedora"><a class="header" href="#for-fedora">For Fedora:</a></h6>
<p>Copy the example service file:</p>
<pre><code class="language-bash">sudo cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service
</code></pre>
<p>Edit the service file:</p>
<pre><code class="language-bash">sudo nano /etc/systemd/system/vncserver@:1.service
</code></pre>
<p>Replace <code>&lt;USER&gt;</code> with your username in the file.</p>
<h6 id="3-configure-vnc-startup-script"><a class="header" href="#3-configure-vnc-startup-script">3. Configure VNC Startup Script</a></h6>
<p>Create or edit the VNC startup script:</p>
<pre><code class="language-bash">nano ~/.vnc/xstartup
</code></pre>
<p>Add the following content:</p>
<pre><code class="language-bash">#!/bin/bash
xrdb $HOME/.Xresources
startxfce4 &amp;
</code></pre>
<p>Make it executable:</p>
<pre><code class="language-bash">chmod +x ~/.vnc/xstartup
</code></pre>
<h5 id="starting-vnc-server"><a class="header" href="#starting-vnc-server">Starting VNC Server</a></h5>
<h6 id="manual-start"><a class="header" href="#manual-start">Manual Start</a></h6>
<pre><code class="language-bash">vncserver :1 -geometry 1024x768 -depth 24 -localhost
</code></pre>
<h6 id="using-systemd-recommended"><a class="header" href="#using-systemd-recommended">Using Systemd (recommended)</a></h6>
<pre><code class="language-bash"># Enable and start the service
sudo systemctl enable vncserver@:1.service
sudo systemctl start vncserver@:1.service

# Check status
sudo systemctl status vncserver@:1.service
</code></pre>
<h5 id="connecting-to-vnc"><a class="header" href="#connecting-to-vnc">Connecting to VNC</a></h5>
<h6 id="local-connection"><a class="header" href="#local-connection">Local Connection</a></h6>
<pre><code class="language-bash">vncviewer localhost:5901
</code></pre>
<h6 id="ssh-tunnel-recommended-for-remote-access"><a class="header" href="#ssh-tunnel-recommended-for-remote-access">SSH Tunnel (recommended for remote access)</a></h6>
<pre><code class="language-bash">ssh -L 5901:localhost:5901 username@remote-server
# Then connect to localhost:5901
</code></pre>
<h5 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h5>
<ol>
<li><strong>Always use SSH tunneling</strong> for remote connections</li>
<li><strong>Bind to localhost only</strong> using the <code>-localhost</code> option</li>
<li><strong>Use strong passwords</strong> with <code>vncpasswd</code></li>
<li><strong>Consider using x11vnc</strong> for sharing existing X sessions instead of creating new ones</li>
</ol>
<h5 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h5>
<h6 id="check-vnc-server-status"><a class="header" href="#check-vnc-server-status">Check VNC server status</a></h6>
<pre><code class="language-bash">vncserver -list
</code></pre>
<h6 id="kill-vnc-session"><a class="header" href="#kill-vnc-session">Kill VNC session</a></h6>
<pre><code class="language-bash">vncserver -kill :1
</code></pre>
<h6 id="view-vnc-logs"><a class="header" href="#view-vnc-logs">View VNC logs</a></h6>
<pre><code class="language-bash">tail -f ~/.vnc/*.log
</code></pre>
<h6 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h6>
<ol>
<li><strong>Display not starting</strong>: Check <code>~/.vnc/xstartup</code> permissions and desktop environment availability</li>
<li><strong>Connection refused</strong>: Verify firewall settings and that VNC is listening on the correct port</li>
<li><strong>Black screen</strong>: Ensure your desktop environment is properly configured in the startup script</li>
</ol>
<h5 id="alternative-x11vnc-for-existing-sessions"><a class="header" href="#alternative-x11vnc-for-existing-sessions">Alternative: x11vnc for Existing Sessions</a></h5>
<p>If you want to share your current desktop session instead of creating a new one:</p>
<h6 id="installation-2"><a class="header" href="#installation-2">Installation</a></h6>
<pre><code class="language-bash"># Debian/Ubuntu
sudo apt install x11vnc

# Fedora
sudo dnf install x11vnc

# Arch
sudo pacman -S x11vnc
</code></pre>
<h6 id="usage"><a class="header" href="#usage">Usage</a></h6>
<pre><code class="language-bash">x11vnc -display :0 -auth ~/.Xauthority -localhost -rfbauth ~/.vnc/passwd
</code></pre>
<h3 id="lamp-stack-linux-apache-mysql-php-website-setup"><a class="header" href="#lamp-stack-linux-apache-mysql-php-website-setup">LAMP Stack (Linux, Apache, MySQL, PHP) Website Setup</a></h3>
<p>The LAMP stack is a popular web server configuration that includes Linux, Apache, MySQL (or MariaDB), and PHP. This stack is widely used for hosting dynamic websites and web applications.</p>
<h4 id="installing-the-lamp-stack"><a class="header" href="#installing-the-lamp-stack">Installing the LAMP Stack</a></h4>
<h5 id="debianubuntu-1"><a class="header" href="#debianubuntu-1">Debian/Ubuntu</a></h5>
<pre><code class="language-bash"># Update package index
sudo apt update

# Install Apache
sudo apt install apache2

# Install MariaDB (MySQL alternative)
sudo apt install mariadb-server

# Install PHP and common modules
sudo apt install php libapache2-mod-php php-mysql php-cli php-curl php-gd php-mbstring php-xml php-zip

# Enable Apache modules
sudo a2enmod rewrite
sudo systemctl restart apache2

# Secure MariaDB installation
sudo mysql_secure_installation

# Start and enable services
sudo systemctl enable apache2
sudo systemctl enable mariadb
sudo systemctl start apache2
sudo systemctl start mariadb
</code></pre>
<h5 id="fedorarhel"><a class="header" href="#fedorarhel">Fedora/RHEL</a></h5>
<pre><code class="language-bash"># Update system
sudo dnf update

# Install Apache
sudo dnf install httpd

# Install MariaDB
sudo dnf install mariadb-server

# Install PHP and modules
sudo dnf install php php-mysqlnd php-cli php-curl php-gd php-mbstring php-xml php-zip

# Start and enable services
sudo systemctl enable httpd
sudo systemctl enable mariadb
sudo systemctl start httpd
sudo systemctl start mariadb

# Secure MariaDB installation
sudo mysql_secure_installation

# Configure firewall
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
</code></pre>
<h5 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h5>
<pre><code class="language-bash"># Update system
sudo pacman -Syu

# Install Apache
sudo pacman -S apache

# Install MariaDB
sudo pacman -S mariadb

# Install PHP and modules
sudo pacman -S php php-apache php-mysql php-gd php-curl

# Initialize MariaDB
sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql

# Configure PHP with Apache
sudo nano /etc/httpd/conf/httpd.conf
# Add these lines:
# LoadModule php_module modules/libphp.so
# AddHandler php-script .php
# Include conf/extra/php_module.conf

# Start and enable services
sudo systemctl enable httpd
sudo systemctl enable mariadb
sudo systemctl start httpd
sudo systemctl start mariadb

# Secure MariaDB installation
sudo mysql_secure_installation
</code></pre>
<h4 id="testing-the-lamp-stack"><a class="header" href="#testing-the-lamp-stack">Testing the LAMP Stack</a></h4>
<h5 id="test-php-installation"><a class="header" href="#test-php-installation">Test PHP installation</a></h5>
<p>echo "<?php phpinfo(); ?>" | sudo tee /var/www/html/info.php</p>
<h5 id="create-a-test-database-optional"><a class="header" href="#create-a-test-database-optional">Create a test database (optional)</a></h5>
<pre><code>sudo mysql -u root -p
# CREATE DATABASE testdb;
# CREATE USER 'testuser'@'localhost' IDENTIFIED BY 'password';
# GRANT ALL PRIVILEGES ON testdb.* TO 'testuser'@'localhost';
# FLUSH PRIVILEGES;
# EXIT;
</code></pre>
<p><strong>Set proper permissions</strong></p>
<pre><code class="language-bash"># Set ownership of the web directory
sudo chown -R www-data:www-data /var/www/html  # Debian/Ubuntu
sudo chown -R apache:apache /var/www/html      # Fedora/Arch
</code></pre>
<h5 id="access-the-test-page"><a class="header" href="#access-the-test-page">Access the test page</a></h5>
<p>Open a web browser and navigate to <code>http://your_server_ip/info.php</code>. You should see the PHP information page, confirming that PHP is working correctly with Apache.</p>
<h5 id="remove-the-test-page"><a class="header" href="#remove-the-test-page">Remove the test page</a></h5>
<pre><code class="language-bash">sudo rm /var/www/html/info.php
</code></pre>
<h5 id="enable-https-in-apache"><a class="header" href="#enable-https-in-apache">Enable HTTPS in Apache</a></h5>
<p>To enable HTTPS, you need to install an SSL certificate. You can use Let's Encrypt for free SSL certificates.</p>
<h5 id="install-certbot"><a class="header" href="#install-certbot">Install Certbot</a></h5>
<pre><code class="language-bash"># Debian/Ubuntu
sudo apt install certbot python3-certbot-apache
# Fedora/RHEL
sudo dnf install certbot python3-certbot-apache
# Arch Linux
sudo pacman -S certbot certbot-apache
</code></pre>
<h5 id="obtain-and-install-ssl-certificate"><a class="header" href="#obtain-and-install-ssl-certificate">Obtain and Install SSL Certificate</a></h5>
<pre><code class="language-bash">sudo certbot --apache -d your_domain.com -d www.your_domain.com
</code></pre>
<p>This command will automatically configure Apache to use the SSL certificate. Follow the prompts to complete the installation.</p>
<h5 id="verify-ssl-configuration"><a class="header" href="#verify-ssl-configuration">Verify SSL Configuration</a></h5>
<p>After obtaining the SSL certificate, you can verify the configuration by accessing your website using <code>https://your_domain.com</code>. You should see a secure connection with a padlock icon in the browser's address bar.</p>
<h5 id="renew-ssl-certificate"><a class="header" href="#renew-ssl-certificate">Renew SSL Certificate</a></h5>
<p>Let's Encrypt certificates are valid for 90 days. To renew the certificate automatically, you can set up a cron job or use the systemd timer.</p>
<pre><code class="language-bash"># Test renewal process
sudo certbot renew --dry-run
</code></pre>
<h5 id="set-up-a-cron-job-for-automatic-renewal"><a class="header" href="#set-up-a-cron-job-for-automatic-renewal">Set up a cron job for automatic renewal</a></h5>
<pre><code class="language-bash"># Open the crontab editor
crontab -e
# Add the following line to run the renewal command daily
0 0 * * * /usr/bin/certbot renew --quiet
</code></pre>
<h3 id="finding-ip-address-and-hostname"><a class="header" href="#finding-ip-address-and-hostname">Finding IP Address and Hostname</a></h3>
<p>To find your server's IP address and hostname, you can use the following commands:</p>
<pre><code class="language-bash"># Find IP address
curl ifconfig.me  # Get the public IP address
curl ipinfo.io/ip  # Another way to get the public IP address
ip addr show  # Show all network interfaces and their IP addresses
ip a  # Shorter version of the above command
ip route get 1  # Get the default route and associated IP address
# Find private IP address
hostname -I  # Get the private IP address(es) of the server
</code></pre>
<h3 id="find-hostname"><a class="header" href="#find-hostname">Find hostname</a></h3>
<pre><code class="language-bash">hostname  # Get the hostname
hostname -f  # Get the fully qualified domain name (FQDN)
</code></pre>
<footer id="last-change">Last change: 2025-06-24</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="drives-and-filesystems"><a class="header" href="#drives-and-filesystems">Drives and Filesystems</a></h1>
<ul>
<li><a href="chapter5-drives.html#understanding-drives-and-filesystems">Understanding Drives and Filesystems</a>
<ul>
<li><a href="chapter5-drives.html#common-filesystem-types">Common Filesystem Types</a></li>
<li><a href="chapter5-drives.html#drive-management-tools">Drive Management Tools</a></li>
</ul>
</li>
<li><a href="chapter5-drives.html#mounting-and-unmounting-drives">Mounting and Unmounting Drives</a>
<ul>
<li><a href="chapter5-drives.html#mounting-drives">Mounting Drives</a></li>
<li><a href="chapter5-drives.html#unmounting-drives">Unmounting Drives</a></li>
</ul>
</li>
<li><a href="chapter5-drives.html#filesystem-management">Filesystem Management</a>
<ul>
<li><a href="chapter5-drives.html#creating-filesystems">Creating Filesystems</a></li>
<li><a href="chapter5-drives.html#checking-filesystems">Checking Filesystems</a></li>
<li><a href="chapter5-drives.html#viewing-filesystem-information">Viewing Filesystem Information</a></li>
<li><a href="chapter5-drives.html#fstab-configuration">Fstab Configuration</a></li>
</ul>
</li>
</ul>
<p>This chapter focuses on managing drives and filesystems in Linux, including mounting and unmounting drives, understanding filesystems, and using tools like <code>fdisk</code>, <code>mkfs</code>, and <code>fsck</code>.</p>
<h2 id="understanding-drives-and-filesystems"><a class="header" href="#understanding-drives-and-filesystems">Understanding Drives and Filesystems</a></h2>
<p>In Linux, drives and filesystems are fundamental components that allow the operating system to store and retrieve data. Each drive can have one or more partitions, and each partition can be formatted with a specific filesystem type.</p>
<h3 id="common-filesystem-types"><a class="header" href="#common-filesystem-types">Common Filesystem Types</a></h3>
<ul>
<li><strong>ext4</strong>: The most common filesystem for Linux, known for its performance and reliability.</li>
<li><strong>xfs</strong>: A high-performance filesystem often used for large files and high-capacity storage.</li>
<li><strong>btrfs</strong>: A modern filesystem with advanced features like snapshots and dynamic resizing.</li>
<li><strong>vfat</strong>: A filesystem compatible with Windows, often used for USB drives, external storage, and EFI boot partitions.</li>
<li><strong>ntfs</strong>: The Windows NT filesystem, used for compatibility with Windows systems.</li>
<li><strong>swap</strong>: A special filesystem used for swap space, which is used when the system runs out of RAM.</li>
</ul>
<p>Personally, I use <code>ext4</code> for most of my drives, <code>xfs</code> for large data storage, and <code>vfat</code> for USB drives and EFI partitions. I avoid <code>btrfs</code> due to its complexity and potential issues with data integrity, although it has improved significantly in recent years. If you are interested in using <code>btrfs</code> check out this article and video I wrote about it: <a href="https://christitus.com/btrfs-guide/">https://christitus.com/btrfs-guide/</a>. The biggest advantage of <code>btrfs</code> is its ability to take snapshots, which can be useful for backups and system recovery. However, it requires more advanced knowledge to manage effectively.</p>
<h3 id="drive-management-tools"><a class="header" href="#drive-management-tools">Drive Management Tools</a></h3>
<ul>
<li><strong>fdisk</strong>: A command-line utility for managing disk partitions. It allows you to create, delete, and modify partitions on a disk.</li>
<li><strong>parted</strong>: A more advanced command-line utility for managing disk partitions, supporting larger disks and more complex partitioning schemes.</li>
<li><strong>lsblk</strong>: A command-line utility that lists block devices, including drives and partitions, along with their mount points and filesystem types.</li>
<li><strong>blkid</strong>: A command-line utility that displays information about block devices, including their UUIDs and filesystem types.</li>
<li><strong>df</strong>: A command-line utility that displays disk space usage for mounted filesystems.</li>
<li><strong>du</strong>: A command-line utility that estimates file and directory space usage.</li>
<li><strong>mount</strong>: A command-line utility that mounts filesystems to specific directories, allowing access to the data stored on those filesystems.</li>
<li><strong>umount</strong>: A command-line utility that unmounts filesystems, making them inaccessible until remounted.</li>
<li><strong>mkfs</strong>: A command-line utility that creates a filesystem on a partition or disk.</li>
<li><strong>fsck</strong>: A command-line utility that checks and repairs filesystems for errors.</li>
<li><strong>lsusb</strong>: A command-line utility that lists USB devices connected to the system, useful for identifying external drives and other USB peripherals.</li>
<li><strong>lspci</strong>: A command-line utility that lists PCI devices, including internal drives and controllers.</li>
<li><strong>smartctl</strong>: A command-line utility that monitors the health of hard drives and SSDs using S.M.A.R.T. (Self-Monitoring, Analysis, and Reporting Technology) data.</li>
<li><strong>hdparm</strong>: A command-line utility that allows you to configure and manage hard drives, including setting power management options and testing drive performance.</li>
<li><strong>gparted</strong>: A graphical partition editor that allows you to create, delete, and modify partitions on a disk using a user-friendly interface.</li>
</ul>
<h2 id="mounting-and-unmounting-drives"><a class="header" href="#mounting-and-unmounting-drives">Mounting and Unmounting Drives</a></h2>
<p>Mounting and unmounting drives is a common task in Linux, especially when dealing with external storage devices or network shares.</p>
<p>Mount commands:</p>
<pre><code class="language-bash"># Mount a filesystem
sudo mount /dev/sdX1 /mnt/mydrive
# Unmount a filesystem
sudo umount /mnt/mydrive
</code></pre>
<h3 id="mounting-drives"><a class="header" href="#mounting-drives">Mounting Drives</a></h3>
<p>To mount a drive, you need to specify the device (e.g., <code>/dev/sda1</code>) and the mount point (e.g., <code>/mnt/mydrive</code>). The mount point is a directory where the contents of the drive will be accessible.
You can also specify the filesystem type and mount options if needed. For example, to mount an ext4 filesystem with read-write permissions, you can use:</p>
<pre><code class="language-bash">sudo mount -t ext4 -o rw /dev/sdX1 /mnt/mydrive
</code></pre>
<p>Where <code>-t</code> specifies the filesystem type and <code>-o</code> specifies mount options.</p>
<h3 id="unmounting-drives"><a class="header" href="#unmounting-drives">Unmounting Drives</a></h3>
<p>To unmount a drive, you can use the <code>umount</code> command followed by the mount point or device name. For example:</p>
<pre><code class="language-bash">sudo umount /mnt/mydrive
</code></pre>
<p>If the drive is busy or in use, you may need to close any open files or processes using it before unmounting. You can also use the <code>-l</code> option to perform a lazy unmount, which detaches the filesystem but allows it to be cleaned up later:</p>
<pre><code class="language-bash">sudo umount -l /mnt/mydrive
</code></pre>
<h2 id="filesystem-management"><a class="header" href="#filesystem-management">Filesystem Management</a></h2>
<p>Managing filesystems in Linux involves creating, formatting, and checking filesystems on drives and partitions. This section covers the essential commands and tools for filesystem management.</p>
<h3 id="creating-filesystems"><a class="header" href="#creating-filesystems">Creating Filesystems</a></h3>
<p><strong>WARNING: Creating a filesystem will erase and format all data on the partition. Ensure you have backups of any important data before proceeding.</strong></p>
<p>To create a filesystem on a partition, you can use the <code>mkfs</code> command followed by the filesystem type and the device name. For example, to create an ext4 filesystem on <code>/dev/sdX1</code>, you can use:</p>
<pre><code class="language-bash">sudo mkfs.ext4 /dev/sdX1
</code></pre>
<p>You can also specify other filesystem types, such as <code>mkfs.xfs</code> for XFS or <code>mkfs.fat -F 32</code> for FAT32. For example:</p>
<pre><code class="language-bash">sudo mkfs.xfs /dev/sdX1
sudo mkfs.fat -F 32 /dev/sdX1
</code></pre>
<p><em>Note: When dealing with EFI System Partitions (ESP), I recommend referring to the this docuumentation: <a href="https://wiki.archlinux.org/title/EFI_system_partition">https://wiki.archlinux.org/title/EFI_system_partition</a> for the most up-to-date information on creating and managing ESPs.</em></p>
<h3 id="checking-filesystems"><a class="header" href="#checking-filesystems">Checking Filesystems</a></h3>
<p>To check a filesystem for errors, you can use the <code>fsck</code> command followed by the device name. For example, to check an ext4 filesystem on <code>/dev/sdX1</code>, you can use:</p>
<pre><code class="language-bash">sudo fsck.ext4 /dev/sdX1
</code></pre>
<p>If you want to automatically fix errors, you can use the <code>-y</code> option:</p>
<pre><code class="language-bash">sudo fsck.ext4 -y /dev/sdX1
</code></pre>
<h3 id="viewing-filesystem-information"><a class="header" href="#viewing-filesystem-information">Viewing Filesystem Information</a></h3>
<p>To view information about filesystems, you can use the <code>df</code> command, which displays disk space usage for mounted filesystems. For example:</p>
<pre><code class="language-bash">df -h
</code></pre>
<p>This command shows the disk space usage in a human-readable format, including the total size, used space, available space, and mount points for each filesystem.</p>
<h3 id="fstab-configuration"><a class="header" href="#fstab-configuration">Fstab Configuration</a></h3>
<p>The <code>/etc/fstab</code> file is used to define how disk partitions, network shares, and other file systems are mounted at boot time. Each line in the file represents a file system and its mount options.</p>
<p>Fstab structure:</p>
<ul>
<li>Device: usually the given name or UUID of the mounted device (sda1/sda2/etc).</li>
<li>Mount Point: designates the directory where the device is/will be mounted.</li>
<li>File System Type: nothing trick here, shows the type of filesystem in use.
Options: lists any active mount options. If using multiple options they must be separated by commas.</li>
<li>Backup Operation: (the first digit) this is a binary system where 1 = dump utility backup of a partition. 0 = no backup. This is an outdated backup method and should <strong>NOT</strong> be used.</li>
<li>File System Check Order: (second digit) Here we can see three possible outcomes.  0 means that fsck will not check the filesystem. Numbers higher than this represent the check order. The root filesystem should be set to 1 and other partitions set to 2.</li>
</ul>
<p>Stntax:</p>
<pre><code># &lt;device&gt; &lt;mount point&gt; &lt;file system type&gt; &lt;options&gt; &lt;backup operation&gt; &lt;fsck order&gt;
</code></pre>
<p>Example:</p>
<pre><code>UUID=1234-5678 /mnt/data  ext4 defaults 0 2
/dev/sdb1      /media/usb vfat defaults,nofail 0 0
</code></pre>
<p>Options:</p>
<ul>
<li><code>defaults</code>: Use default mount options.</li>
<li><code>nofail</code>: Ignore errors when mounting the filesystem.</li>
<li><code>noauto</code>: Do not mount automatically at boot.</li>
<li><code>user</code>: Allow non-root users to mount the filesystem.</li>
<li><code>rw</code>: Mount the filesystem as read-write.</li>
<li><code>ro</code>: Mount the filesystem as read-only.</li>
<li><code>exec</code>: Allow execution of binaries on the filesystem.</li>
<li><code>noexec</code>: Prevent execution of binaries on the filesystem.</li>
<li><code>sync</code>: All I/O operations are done synchronously.</li>
<li><code>async</code>: All I/O operations are done asynchronously.</li>
<li><code>uid=1000</code>: Set the owner of the mounted filesystem to user ID 1000.</li>
<li><code>gid=1000</code>: Set the group of the mounted filesystem to group ID 1000.</li>
<li><code>umask=022</code>: Set the default permissions for files and directories on the mounted filesystem.</li>
<li><code>dmask=027</code>: Set the default permissions for directories on the mounted filesystem.</li>
<li><code>fmask=133</code>: Set the default permissions for files on the mounted filesystem.</li>
</ul>
<p>My fstab file with NFS mounts and multiple drives:</p>
<pre><code># Static information about the filesystems.
# See fstab(5) for details.

# &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;
# /dev/nvme1n1p2
UUID=1188f001-7a26-4d75-819f-202e4ef2da96	/         	ext4      	rw,relatime	0 1

# /dev/nvme1n1p1
UUID=3337-A669      	/boot     	vfat      	rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro	0 2

# /dev/nvme1n1p3
UUID=df8df26b-3bdc-427d-be86-43d6a25208b4	/home     	ext4      	rw,relatime	0 2

# Network Drives
10.0.0.2:/volume2/Images		/media/images	nfs	x-systemd.after=network-online.target,x-systemd.automount,x-systemd.mount-timeout=90,_netdev 0 0
</code></pre>
<footer id="last-change">Last change: 2025-06-16</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="linux-hardware-compatibility"><a class="header" href="#linux-hardware-compatibility">Linux Hardware Compatibility</a></h1>
<ul>
<li><a href="chapter6-hardware.html#incompatible-hardware">Incompatible Hardware</a></li>
<li><a href="chapter6-hardware.html#checking-compatibility">Checking Compatibility</a></li>
<li><a href="chapter6-hardware.html#conclusion">Conclusion</a></li>
</ul>
<p>The biggest myth told by the Linux community is that Linux works on all hardware. This is not true, and it is a common misconception that leads to many users being disappointed when they try to install Linux on their machines. The reality is that while Linux supports a wide range of hardware, there are still many devices that do not work well or at all with Linux.</p>
<h2 id="incompatible-hardware"><a class="header" href="#incompatible-hardware">Incompatible Hardware</a></h2>
<p>Some hardware is simply not compatible with Linux. This can be due to a lack of drivers, proprietary firmware, or other issues. For example, some Wi-Fi adapters, graphics cards, and printers may not work properly on Linux. Before installing Linux, it is essential to check the compatibility of your hardware.</p>
<p>Hardware I've personally had issues with includes:</p>
<ul>
<li><strong>NVIDIA Graphics Cards</strong>: While NVIDIA provides proprietary drivers for Linux, they can be difficult to install and may not work with all distributions. Open-source alternatives like Nouveau exist but often lack performance and features. This is getting better with each kernel release, and nVidia open sourcing their drives, but still is a common issue. I've had issues with obscure Wayland configurations, Custom Linux Kernels, and certain desktop environments that do not play well with NVIDIA drivers. AMD graphics is still the best option for Linux users by a large margin. Keep an eye on the official NVIDIA open source drivers with the package <code>nvidia-open</code> for your distribution, as they are improving over time. Arch Linux users will be the first to see these improvements, as they are the first to implement new features. Debian and Ubuntu users typically see these improvements about 6 months later, and Fedora users about 3 months later. However, LTS releases will take longer to update.</li>
<li><strong>Broadcom Wi-Fi Adapters</strong>: Many Broadcom Wi-Fi adapters require proprietary drivers that are not included in the Linux kernel by default. This can lead to connectivity issues.</li>
<li><strong>Certain Printers</strong>: Some printers, especially those from manufacturers like HP and Canon, may not have Linux drivers available or may require additional configuration to work correctly.</li>
<li><strong>Fingerprint Readers</strong>: Many fingerprint readers do not have Linux support, making them unusable for authentication purposes.</li>
<li><strong>Webcams</strong>: Some webcams, particularly older models, may not be recognized by Linux or may require additional drivers to function correctly.</li>
<li><strong>Bluetooth Adapters</strong>: Some Bluetooth adapters may not work out of the box and require additional drivers or configuration.</li>
<li><strong>Touchpads</strong>: Some touchpads, especially those with advanced features, may not work correctly without additional configuration or drivers.</li>
<li><strong>Audio Devices</strong>: Some audio devices, particularly those with proprietary drivers, may not work correctly on Linux.</li>
<li><strong>Gaming Peripherals</strong>: Many gaming mice and keyboards may not have full functionality on Linux, especially those with customizable features.</li>
<li><strong>Virtual Reality Headsets</strong>: Many VR headsets do not have Linux support, making them unusable for gaming or other applications.</li>
</ul>
<h2 id="checking-compatibility"><a class="header" href="#checking-compatibility">Checking Compatibility</a></h2>
<p>Before installing Linux, it is crucial to check the compatibility of your hardware. Here are some resources to help you determine if your hardware is compatible with Linux:</p>
<ul>
<li><strong>Linux Hardware Compatibility Lists</strong>: Websites like <a href="https://linux-hardware.org/">Linux Hardware</a> provide lists of hardware that is known to work well with Linux.</li>
<li><strong>Distribution-Specific Compatibility Lists</strong>: Many Linux distributions maintain their own hardware compatibility lists. For example, <a href="https://wiki.ubuntu.com/HardwareSupport">Ubuntu's Hardware Compatibility</a> page provides information on supported devices.</li>
<li><strong>Forums and Communities</strong>: Online forums and communities, such as the <a href="https://www.linuxquestions.org/">LinuxQuestions.org</a> or the <a href="https://www.reddit.com/r/linux4noobs/">Linux 4 Noobs Subreddit</a>, can be valuable resources for checking hardware compatibility. Users often share their experiences with specific hardware and Linux distributions.</li>
<li><strong>Manufacturer Websites</strong>: Some hardware manufacturers provide information on Linux compatibility for their products. Check the manufacturer's website for any available drivers or support documentation.</li>
<li><strong>Distro-Specific Tools</strong>: Some Linux distributions come with tools that can help you check hardware compatibility. <code>lshw</code> (List Hardware) is a command-line utility that provides detailed information about your system's hardware. You can use it to check if your hardware is recognized by the Linux kernel.</li>
<li><strong>Live USB Testing</strong>: Before installing Linux, you can create a live USB of the distribution you want to try. Booting from the live USB allows you to test hardware compatibility without making any changes to your system. This is a great way to see if your hardware works well with Linux before committing to an installation.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>While Linux supports a wide range of hardware, it is essential to be aware of potential compatibility issues. Before installing Linux, check the compatibility of your hardware using the resources mentioned above. By doing so, you can avoid disappointment and ensure a smooth installation and usage experience with Linux.</p>
<footer id="last-change">Last change: 2025-06-18</footer><div style="break-before: page; page-break-before: always;"></div><h1 id="linux-programs"><a class="header" href="#linux-programs">Linux Programs</a></h1>
<p>Many windows and macOS users try to use all their favorite programs on Linux, but this is not always possible. Some programs are not available for Linux, while others may have limited functionality or require additional configuration to work correctly. This section covers some common Linux programs and alternatives to popular Windows and macOS applications.</p>
<h2 id="common-linux-programs"><a class="header" href="#common-linux-programs">Common Linux Programs</a></h2>
<p>Linux has a wide range of programs available for various tasks, including productivity, multimedia, development, and more. For an exhaustive list of programs built and maintained by the Linux community: <a href="https://github.com/luong-komorebi/Awesome-Linux-Software">https://github.com/luong-komorebi/Awesome-Linux-Software</a>, but here are some common Linux programs I use and recommend:</p>
<h3 id="communication-and-messaging"><a class="header" href="#communication-and-messaging">Communication and Messaging:</a></h3>
<ul>
<li><strong>Discord</strong>: A communication platform designed for gamers that is available on Linux. It allows you to chat, voice call, and video call with friends and communities.</li>
<li><strong>Signal</strong>: A privacy-focused messaging app that is available on Linux. It provides end-to-end encryption for secure messaging and voice calls.</li>
<li><strong>Slack</strong>: A collaboration and communication platform that is available on Linux. It allows teams to communicate, share files, and collaborate on projects.</li>
<li><strong>Telegram</strong>: A messaging app that is available on Linux. It provides secure messaging, file sharing, and group chats.</li>
<li><strong>Thunderbird</strong>: An email client developed by Mozilla, similar to Microsoft Outlook. It supports multiple email accounts, RSS feeds, and newsgroups.</li>
<li><strong>Zoom</strong>: A video conferencing and online meeting platform that is available on Linux. It allows you to host and join meetings, webinars, and virtual events.</li>
</ul>
<h3 id="development-and-system-tools"><a class="header" href="#development-and-system-tools">Development and System Tools:</a></h3>
<ul>
<li><strong>Docker</strong>: A platform for developing, shipping, and running applications in containers. It allows you to run applications in isolated environments, making it easier to manage dependencies and configurations.</li>
<li><strong>Notepadqq</strong> (Notepad++ alternative): A text editor for Linux that provides syntax highlighting, code folding, and other features for programming.</li>
<li><strong>Snap and Flatpak</strong>: Package management systems that allow you to install and run applications in isolated environments. They provide a way to run applications without worrying about dependencies and compatibility issues.</li>
<li><strong>Visual Studio Code</strong>: A lightweight code editor developed by Microsoft that supports various programming languages and extensions. It is a popular choice for developers on Linux.</li>
</ul>
<h3 id="office-and-productivity"><a class="header" href="#office-and-productivity">Office and Productivity:</a></h3>
<ul>
<li><strong>Firefox</strong>: A popular web browser that is known for its speed, security, and privacy features. It is a great alternative to Google Chrome and Microsoft Edge.</li>
<li><strong>LibreOffice</strong>: A free and open-source office suite that includes a word processor, spreadsheet application, presentation software, and more. It is a popular alternative to Microsoft Office.</li>
<li><strong>Nextcloud</strong>: A self-hosted cloud storage solution that allows you to store, share, and sync files across devices. It is a popular alternative to Google Drive and Dropbox.</li>
<li><strong>OnlyOffice</strong>: An open-source office suite that provides a word processor, spreadsheet editor, and presentation software. It is compatible with Microsoft Office formats and offers collaborative features.</li>
</ul>
<h3 id="multimedia-and-creative-tools"><a class="header" href="#multimedia-and-creative-tools">Multimedia and Creative Tools:</a></h3>
<ul>
<li><strong>Audacity</strong>: A free and open-source audio editing program that allows you to record, edit, and manipulate audio files. It is a popular choice for podcasting and music production.</li>
<li><strong>Blender</strong>: A powerful 3D modeling, animation, and rendering software that is widely used in the film and gaming industries. It is a popular alternative to Autodesk Maya and 3ds Max.</li>
<li><strong>Calibre</strong>: An e-book management software that allows you to organize, convert, and read e-books. It supports various e-book formats and provides features for managing your e-book library.</li>
<li><strong>GIMP</strong>: A powerful image editing program that is often compared to Adobe Photoshop. It supports a wide range of image formats and provides advanced editing features.</li>
<li><strong>Inkscape</strong>: A vector graphics editor that is similar to Adobe Illustrator. It is used for creating and editing vector images and supports various file formats.</li>
<li><strong>Kdenlive</strong>: A non-linear video editor that is popular among Linux users. It provides a wide range of features for video editing, including multi-track editing, effects, and transitions.</li>
<li><strong>Krita</strong>: A digital painting program that is popular among artists and illustrators. It provides a wide range of brushes, tools, and features for creating digital art.</li>
<li><strong>OBS Studio</strong>: An open-source software for video recording and live streaming. It is widely used by content creators and streamers on platforms like Twitch and YouTube.</li>
<li><strong>Spotify</strong>: A music streaming service that is available on Linux. It allows you to listen to millions of songs and create playlists.</li>
<li><strong>VLC Media Player</strong>: A versatile media player that supports a wide range of audio and video formats. It is a popular alternative to Windows Media Player and QuickTime.</li>
</ul>
<h3 id="gaming-and-compatibility"><a class="header" href="#gaming-and-compatibility">Gaming and Compatibility:</a></h3>
<ul>
<li><strong>Bottles</strong>: A tool that allows you to run Windows games and applications on Linux using Wine. It provides a user-friendly interface for managing Wine prefixes and configurations.</li>
<li><strong>Heroic Games Launcher</strong>: An open-source game launcher for the Epic Games Store that allows you to install and play Epic Games on Linux. It provides a user-friendly interface and supports various game configurations.</li>
<li><strong>Lutris</strong>: A gaming platform that allows you to install and manage games from various sources, including Steam, GOG, and Battle.net. It provides a unified interface for launching games and managing game libraries.</li>
<li><strong>Steam</strong>: A digital distribution platform for video games that is available on Linux. It allows you to purchase, download, and play games from a vast library.</li>
<li><strong>Wine</strong>: A compatibility layer that allows you to run Windows applications on Linux. It is not a perfect solution, but it can be useful for running certain Windows programs that do not have native Linux alternatives.</li>
</ul>
<h2 id="linux-gaming"><a class="header" href="#linux-gaming">Linux Gaming</a></h2>
<p>Linux gaming has come a long way in recent years, with many popular games now available natively on the platform. Additionally, tools like Proton (a compatibility layer for running Windows games on Linux) and Lutris (a gaming platform for managing games from various sources) have made it easier to play games on Linux. If you want to play a lot of games on Linux and do not want to do much configuration, I recommend using either Bazzite or Nobara Linux, which are both gaming-focused distributions that come pre-configured with the necessary tools and drivers for gaming. Starting from a fresh blank distribution like Debian or Arch Linux can be challenging for gaming, as you will need to manually install and configure various components to get games running smoothly.</p>
<h3 id="understanding-wine-and-proton"><a class="header" href="#understanding-wine-and-proton">Understanding WINE and Proton</a></h3>
<p>WINE (Wine Is Not an Emulator) is a compatibility layer that allows you to run Windows applications on Linux. It translates Windows API calls into POSIX calls, enabling you to run many Windows applications without needing a full Windows installation. Proton is a modified version of WINE developed by Valve, specifically designed to run Windows games on Linux through the Steam platform. It includes additional libraries and optimizations to improve game compatibility and performance.
While WINE and Proton can run many Windows applications and games, they are not perfect solutions. Some applications may not work correctly or may require additional configuration to run smoothly. It is essential to check compatibility reports on sites like <a href="https://www.protondb.com/">ProtonDB</a> to see if a specific game or application is supported and to find any necessary tweaks or workarounds.</p>
<p>Lutris is a front-end for managing games on Linux, providing a user-friendly interface for installing and launching games from various sources, including Steam, GOG, and Battle.net. It supports WINE and Proton, allowing you to run Windows games on Linux with ease. Lutris also provides scripts for installing specific games, which can simplify the setup process.</p>
<p>Heroic Games Launcher is an open-source game launcher for the Epic Games Store that allows you to install and play Epic Games on Linux. It provides a user-friendly interface and supports various game configurations, making it easier to manage your Epic Games library on Linux.</p>
<p>Bottles is a front-end for WINE that simplifies the process of running Windows applications on Linux. It provides a user-friendly interface for managing WINE prefixes and configurations, making it easier to run Windows games and applications without needing extensive knowledge of WINE.</p>
<h4 id="wine-usage"><a class="header" href="#wine-usage">WINE Usage</a></h4>
<p>WINE is a powerful tool for running Windows applications on Linux, but it can be complex to set up and use effectively. Here are some tips for using WINE:</p>
<ol>
<li>
<p><strong>Installation</strong>: Install WINE using your distribution's package manager. For example, on Ubuntu, you can use:</p>
<pre><code class="language-bash">sudo apt install wine
</code></pre>
<p>On Arch Linux, you can use:</p>
<pre><code class="language-bash">sudo pacman -S wine
</code></pre>
</li>
<li>
<p><strong>Configuration</strong>: After installing WINE, you can run <code>winecfg</code> in the terminal to configure WINE settings. This will create a default WINE prefix in your home directory (<code>~/.wine</code>) and allow you to set various options, such as the Windows version to emulate, graphics settings, and audio configurations.</p>
</li>
<li>
<p><strong>Installing Windows Applications</strong>: To install a Windows application using WINE, you can run the installer executable with the <code>wine</code> command. For example:</p>
<pre><code class="language-bash">wine setup.exe
</code></pre>
<p>Replace <code>setup.exe</code> with the actual name of the installer file. WINE will create a virtual C: drive in your WINE prefix, where the application will be installed.</p>
</li>
<li>
<p><strong>Running Windows Applications</strong>: After installation, you can run the application using WINE by executing the application's executable file. For example:</p>
<pre><code class="language-bash">wine /path/to/application.exe
</code></pre>
<p>Replace <code>/path/to/application.exe</code> with the actual path to the application's executable file.</p>
</li>
<li>
<p><strong>Managing WINE Prefixes</strong>: WINE uses a concept called "prefixes" to manage different environments for running Windows applications. By default, WINE uses the <code>~/.wine</code> directory as its prefix. You can create additional prefixes by setting the <code>WINEPREFIX</code> environment variable before running WINE commands. For example:</p>
<pre><code class="language-bash">WINEPREFIX="/path/to/custom/prefix" wine /path/to/application.exe
</code></pre>
<p>This allows you to maintain separate configurations and installations for different applications, which can be useful for managing dependencies and settings.</p>
</li>
<li>
<p><strong>Using Winetricks</strong>: Winetricks is a script that helps you install various Windows libraries and components in your WINE prefix. It can be useful for installing .NET Framework, DirectX, and other dependencies required by certain applications. You can install Winetricks using your package manager or download it from the <a href="https://github.com/Winetricks/winetricks">Winetricks GitHub repository</a>.</p>
</li>
</ol>
<p>Wine prefixes can get complicated when adding dotnet and other features with winetricks. Unlike Windows, you cannot UNINSTALL dotnet from a WINE prefix, so it is best to create a new prefix for each application that requires different versions of dotnet or other libraries. This way, you can avoid conflicts and ensure that each application has the correct environment to run smoothly. Once you get the application running, do NOT change the WINE prefix or add/remove libraries, as this can break the application. If you need to make changes, create a new prefix and set it up again. This involves deleting the old prefix and starting fresh, but it is the best way to ensure that your applications run smoothly without conflicts.</p>
<h4 id="proton-usage"><a class="header" href="#proton-usage">Proton Usage</a></h4>
<p>Proton is a compatibility layer developed by Valve that allows you to run Windows games on Linux through the Steam platform. It is built on top of WINE and includes additional libraries and optimizations to improve game compatibility and performance. Here are some tips for using Proton:</p>
<ol>
<li>
<p><strong>Installation</strong>:
Proton is integrated into the Steam client, so you do not need to install it separately.
Make sure you have the latest version of Steam installed on your Linux system. You can install Steam using your distribution's package manager. For example, on Ubuntu, you can use:</p>
<pre><code class="language-bash">sudo apt install steam
</code></pre>
<p>On Arch Linux, you can use:</p>
<pre><code class="language-bash">sudo pacman -S steam
</code></pre>
</li>
<li>
<p><strong>Enabling Proton for all games</strong>:
To enable Proton for all games, open the Steam client, go to "Settings," then "Steam Play." Check the box for "Enable Steam Play for all other titles" and select the desired Proton version from the dropdown menu.</p>
</li>
<li>
<p><strong>Installing Proton GE</strong>:
Proton GE (Glorious Eggroll) is a community-maintained version of Proton that includes additional patches and optimizations for specific games. To install Proton GE, you can download it from the <a href="https://github.com/GloriousEggroll/proton-ge-custom/releases">Proton GE GitHub repository</a>.</p>
<p>After downloading, extract the contents to your Steam directory, typically located at <code>~/.steam/root/compatibilitytools.d/</code>. If the <code>compatibilitytools.d</code> directory does not exist, you can create it.
Once extracted, restart the Steam client, and you should see Proton GE listed as an available compatibility tool in the Steam Play settings.</p>
</li>
</ol>
<p>For updating Proton GE, I'd recommend using the <a href="https://github.com/ProtonUp/ProtonUp-Qt">ProtonUp-Qt</a> tool, which provides a user-friendly interface for managing and updating Proton GE installations OR if using the terminal you can use the following command:</p>
<pre><code class="language-bash">protonup -u
</code></pre>
<p>This will update Proton GE to the latest version available. Install protonup through python pip:</p>
<pre><code class="language-bash">pip install protonup
</code></pre>
<footer id="last-change">Last change: 2025-07-14</footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
